{"meta":{"title":"一缕微光","subtitle":"刺破黑暗，闪耀光芒","description":"Victory won't come to me unless I go to it.","author":"ariescc","url":"http://www.ariesjch.top"},"pages":[{"title":"","date":"2018-01-14T19:15:38.000Z","updated":"2018-01-26T01:42:54.898Z","comments":true,"path":"about/index.html","permalink":"http://www.ariesjch.top/about/index.html","excerpt":"","text":"博主 ariescc 现就读于西北工业大学，业余喜欢陶笛、二胡、小提琴。 志向成为一名合格的数据分析师/金融码农,梦想将AI应用于Quant或相关金融领域。 现决心考研，既然选择了远方，便只顾风雨兼程！ 天空透漏着微光 \\照亮虚无迷惘 \\在残垣废墟中 \\寻找唯一梦想 \\ 古老的巨石想象 \\守护神秘光芒 \\清澈的蓝色河流 \\指引真实方向 \\ 穿越了风沙 \\划破了手掌 \\坚定着希望去闯 \\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ———— 张韶涵《梦里花》"},{"title":"categories","date":"2018-01-14T20:29:15.000Z","updated":"2018-01-15T03:04:58.172Z","comments":true,"path":"categories/index.html","permalink":"http://www.ariesjch.top/categories/index.html","excerpt":"","text":""},{"title":"photo","date":"2017-09-18T09:57:16.814Z","updated":"2017-09-18T09:57:16.814Z","comments":true,"path":"photo/index.html","permalink":"http://www.ariesjch.top/photo/index.html","excerpt":"","text":""},{"title":"","date":"2017-09-18T10:17:11.016Z","updated":"2017-09-18T10:17:11.016Z","comments":true,"path":"photo/output.json","permalink":"http://www.ariesjch.top/photo/output.json","excerpt":"","text":"[\"1164F17549E4B11D25E06F683880F37F.jpg\",\"3207E337A0048A28FF9855A1E6B1CABA.jpg\",\"7F9B2EC97B9C3167B6BF524CC1174636.jpg\",\"E5181825ADD4300BB542016728DC560F.jpg\"]"},{"title":"","date":"2017-09-18T09:53:03.376Z","updated":"2017-09-18T09:53:03.376Z","comments":true,"path":"photo/tool.js","permalink":"http://www.ariesjch.top/photo/tool.js","excerpt":"","text":"\"use strict\"; const fs = require(\"fs\"); const path = \"../../photos\"; fs.readdir(path, function (err, files) { if (err) { return; } let arr = []; (function iterator(index) { if (index == files.length) { fs.writeFile(\"output.json\", JSON.stringify(arr, null, \"\\t\")); return; } fs.stat(path + \"/\" + files[index], function (err, stats) { if (err) { return; } if (stats.isFile()) { arr.push(files[index]); } iterator(index + 1); }) }(0)); });"},{"title":"","date":"2018-01-14T20:28:10.000Z","updated":"2018-01-15T03:12:09.129Z","comments":true,"path":"tags/index.html","permalink":"http://www.ariesjch.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"读书人","slug":"读书人","date":"2018-01-25T13:54:47.000Z","updated":"2018-01-26T01:05:40.598Z","comments":true,"path":"2018/01/25/读书人/","link":"","permalink":"http://www.ariesjch.top/2018/01/25/读书人/","excerpt":"","text":"","categories":[{"name":"绘画篇","slug":"绘画篇","permalink":"http://www.ariesjch.top/categories/绘画篇/"}],"tags":[{"name":"画笔","slug":"画笔","permalink":"http://www.ariesjch.top/tags/画笔/"}]},{"title":"相遇","slug":"相遇","date":"2018-01-25T13:54:34.000Z","updated":"2018-01-26T01:06:05.820Z","comments":true,"path":"2018/01/25/相遇/","link":"","permalink":"http://www.ariesjch.top/2018/01/25/相遇/","excerpt":"","text":"","categories":[{"name":"绘画篇","slug":"绘画篇","permalink":"http://www.ariesjch.top/categories/绘画篇/"}],"tags":[{"name":"画笔","slug":"画笔","permalink":"http://www.ariesjch.top/tags/画笔/"}]},{"title":"花旦","slug":"花旦","date":"2018-01-25T13:52:33.000Z","updated":"2018-01-26T01:06:25.953Z","comments":true,"path":"2018/01/25/花旦/","link":"","permalink":"http://www.ariesjch.top/2018/01/25/花旦/","excerpt":"","text":"","categories":[{"name":"绘画篇","slug":"绘画篇","permalink":"http://www.ariesjch.top/categories/绘画篇/"}],"tags":[{"name":"画笔","slug":"画笔","permalink":"http://www.ariesjch.top/tags/画笔/"}]},{"title":"遇见美好","slug":"遇见美好","date":"2018-01-25T13:51:40.000Z","updated":"2018-01-26T01:06:43.435Z","comments":true,"path":"2018/01/25/遇见美好/","link":"","permalink":"http://www.ariesjch.top/2018/01/25/遇见美好/","excerpt":"","text":"","categories":[{"name":"绘画篇","slug":"绘画篇","permalink":"http://www.ariesjch.top/categories/绘画篇/"}],"tags":[{"name":"画笔","slug":"画笔","permalink":"http://www.ariesjch.top/tags/画笔/"}]},{"title":"爱莲说","slug":"爱莲说","date":"2018-01-25T13:50:36.000Z","updated":"2018-01-25T14:14:19.815Z","comments":true,"path":"2018/01/25/爱莲说/","link":"","permalink":"http://www.ariesjch.top/2018/01/25/爱莲说/","excerpt":"","text":"","categories":[{"name":"书法篇","slug":"书法篇","permalink":"http://www.ariesjch.top/categories/书法篇/"}],"tags":[{"name":"丑字","slug":"丑字","permalink":"http://www.ariesjch.top/tags/丑字/"}]},{"title":"成都","slug":"成都","date":"2018-01-25T13:45:43.000Z","updated":"2018-01-25T13:48:13.918Z","comments":true,"path":"2018/01/25/成都/","link":"","permalink":"http://www.ariesjch.top/2018/01/25/成都/","excerpt":"让我掉下眼泪的不止昨夜的酒让我依依不舍的不止你的温柔余路还要走多久你攥着我的手让我感到为难的是挣扎的自由分别总是在九月回忆是思念的愁深秋嫩绿的垂柳亲吻着我额头在那座阴雨的小城里我从未忘记你成都 带不走的 只有你","text":"让我掉下眼泪的不止昨夜的酒让我依依不舍的不止你的温柔余路还要走多久你攥着我的手让我感到为难的是挣扎的自由分别总是在九月回忆是思念的愁深秋嫩绿的垂柳亲吻着我额头在那座阴雨的小城里我从未忘记你成都 带不走的 只有你 和我在成都的街头走一走直到所有的灯都熄灭了也不停留你会挽着我的衣袖我会把手揣进裤兜走到玉林路的尽头坐在小酒馆的门口分别总是在九月回忆是思念的愁深秋嫩绿的垂柳亲吻着我额头在那座阴雨的小城里我从未忘记你成都 带不走的 只有你和我在成都的街头走一走直到所有的灯都熄灭了也不停留你会挽着我的衣袖我会把手揣进裤兜走到玉林路的尽头坐在小酒馆的门口和我在成都的街头走一走直到所有的灯都熄灭了也不停留和我在成都的街头走一走直到所有的灯都熄灭了也不停留你会挽着我的衣袖我会把手揣进裤兜走到玉林路的尽头走过小酒馆的门口和我在成都的街头走一走直到所有的灯都熄灭了也不停留 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —————— 《成都》 赵雷","categories":[{"name":"音乐篇","slug":"音乐篇","permalink":"http://www.ariesjch.top/categories/音乐篇/"}],"tags":[{"name":"那段音符","slug":"那段音符","permalink":"http://www.ariesjch.top/tags/那段音符/"}]},{"title":"阿刁","slug":"阿刁","date":"2018-01-25T13:20:58.000Z","updated":"2018-01-25T13:47:54.883Z","comments":true,"path":"2018/01/25/阿刁/","link":"","permalink":"http://www.ariesjch.top/2018/01/25/阿刁/","excerpt":"阿刁 住在西藏的某个地方秃鹫一样 栖息在山顶上阿刁 大昭寺门前铺满阳光打一壶甜茶 我们聊着过往阿刁 你总把自己打扮的像男孩子一样 可比格桑还顽强阿刁 狡猾的人有千百种笑你何时下山 记得带上卓玛刀 灰色帽檐下 凹陷的脸颊你很少说话 简单的回答明天在哪里 谁会在意你即使死在路上","text":"阿刁 住在西藏的某个地方秃鹫一样 栖息在山顶上阿刁 大昭寺门前铺满阳光打一壶甜茶 我们聊着过往阿刁 你总把自己打扮的像男孩子一样 可比格桑还顽强阿刁 狡猾的人有千百种笑你何时下山 记得带上卓玛刀 灰色帽檐下 凹陷的脸颊你很少说话 简单的回答明天在哪里 谁会在意你即使死在路上 阿刁 明天是否能吃顿饱饭你已习惯 饥饿是一种信仰阿刁 不会被现实磨平稜角你不是这世界的人 没必要在乎真相 命运多舛 痴迷 淡然挥别了青春 数不尽的车站甘于平凡却不甘平凡的腐烂你是阿刁 你是自由的鸟 灰色帽檐下 凹陷的脸颊你很少说话 简单的回答明天在哪里 谁会在意你即使死在路上 命运多舛 痴迷淡然挥别了青春 数不尽的车站甘于平凡却不甘平凡的腐烂你是阿刁 阿刁 爱情是粒悲伤的种子你是一棵树 你永远都不会枯 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;———— 《阿刁》 赵雷","categories":[{"name":"音乐篇","slug":"音乐篇","permalink":"http://www.ariesjch.top/categories/音乐篇/"}],"tags":[{"name":"那段音符","slug":"那段音符","permalink":"http://www.ariesjch.top/tags/那段音符/"}]},{"title":"梦里花","slug":"梦里花","date":"2018-01-25T13:20:42.000Z","updated":"2018-01-25T13:48:44.368Z","comments":true,"path":"2018/01/25/梦里花/","link":"","permalink":"http://www.ariesjch.top/2018/01/25/梦里花/","excerpt":"唯一纯白的茉莉花 \\盛开在琥珀色月牙 \\就算失去所有爱的力量 \\我也不曾害怕 \\天空透露着微光 照亮虚无迷惘 \\在残垣废墟之中 寻找唯一梦想 \\古老的巨石神像 守护神秘时光 \\清澈的蓝色河流 指引着是方向 \\穿越过风沙 划破了手掌 \\坚定着希望 去闯 \\","text":"唯一纯白的茉莉花 \\盛开在琥珀色月牙 \\就算失去所有爱的力量 \\我也不曾害怕 \\天空透露着微光 照亮虚无迷惘 \\在残垣废墟之中 寻找唯一梦想 \\古老的巨石神像 守护神秘时光 \\清澈的蓝色河流 指引着是方向 \\穿越过风沙 划破了手掌 \\坚定着希望 去闯 \\ 唯一纯白的茉莉花 \\盛开在琥珀色月牙 \\就算失去所有爱的力量 \\我也不曾害怕 \\古老的巨石神像 守护神秘时光 \\清澈的蓝色河流 指引着是方向 \\穿越过风沙 划破了手掌 \\坚定着希望 去闯 \\ 唯一纯白的茉莉花 \\盛开在琥珀色月牙 \\就算失去所有爱的力量 \\我也不曾害怕 \\穿越千年的石版画 \\刻划着悠瀚的天堂 \\轻轻拭去满布全身的伤 \\我总不再绝望 \\ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;———— 《梦里花》张韶涵","categories":[{"name":"音乐篇","slug":"音乐篇","permalink":"http://www.ariesjch.top/categories/音乐篇/"}],"tags":[{"name":"那段音符","slug":"那段音符","permalink":"http://www.ariesjch.top/tags/那段音符/"}]},{"title":"文件夹遍历以及子文件读写","slug":"文件夹遍历以及子文件读写","date":"2018-01-25T12:41:41.000Z","updated":"2018-01-25T13:11:27.544Z","comments":true,"path":"2018/01/25/文件夹遍历以及子文件读写/","link":"","permalink":"http://www.ariesjch.top/2018/01/25/文件夹遍历以及子文件读写/","excerpt":"需求分析再给个人博客添加文章分类功能的时候，需要每篇文章添加一个categories: xxx的标签。由于文章数量太多，手动逐一给每篇文章添加标签很费时间，于是用python写了一个小脚本。需求如下： 读取指定文件夹下所有子文件名称 读取指定子文件，并获取子文件内容 向子文件内容的指定位置添加新内容，如题添加categories: xxx","text":"需求分析再给个人博客添加文章分类功能的时候，需要每篇文章添加一个categories: xxx的标签。由于文章数量太多，手动逐一给每篇文章添加标签很费时间，于是用python写了一个小脚本。需求如下： 读取指定文件夹下所有子文件名称 读取指定子文件，并获取子文件内容 向子文件内容的指定位置添加新内容，如题添加categories: xxx 实现过程遍历指定文件夹，获取其目录下的所有子文件名称代码如下:12345678910# 遍历指定目录,获取所有文件名def get_each_filename(folder_path): path_dir = os.listdir(folder_path) child_dirs = [] for all_dir in path_dir: child = os.path.join('%s\\%s' % (folder_path, all_dir)) child_dirs.append(child) #print(child_dirs) return child_dirs 后面需要根据文件名来读写文件，需要给定绝对路径（相对路径不能访问文件），所以在获取子文件名时进行字符串拼接，得到子文件的绝对路径，并存储到一个列表中。 读写子文件代码如下：123456789101112131415161718192021# 每个文件中追加内容def insert_content(filename): lines = [] with open(filename, 'r', encoding = 'utf-8') as f: for line in f: lines.append(line) f.close() print(lines) lines.insert(4, 'categories: 技术篇\\n') s = ''.join(lines) with open(filename, 'w+', encoding = 'utf-8') as f: f.write(s) f.close() del lines[:] print(lines) 这里我是需要将新加内容追加到文本的第4行。f.read()是将文件所有内容一次性读取（读取所有字节），f.readline([size])可以按照指定字节按行读取，但是每行字节很难控制。于是最后做法是先将子文件所有内容一次性读取出来，然后逐行存入一个列表中，通过下标索引指定插入到第4个位置。再将列表内容拼接起来重新写入子文件中。 完整代码完整代码参看我的github: github.com/ariescc 文件 with open 参数说明1234567891011w: 以写方式打开a: 以追加模式打开(从EOF开始，必要时创建新文件)r+: 以读写模式打开w+: 以读写模式打开(参见 w)a+: 以读写模式打开(参见 a)rb: 以二进制读模式打开wb: 以二进制写模式打开ab: 以二进制追加模式打开(参见 a)rb+: 以二进制读写模式打开(参见 r+)wb+: 以二进制读写模式打开(参见 w+)ab+: 以二进制读写模式打开(参见 a+)","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.ariesjch.top/tags/python/"}]},{"title":"HEXO添加字数统计、阅读时长","slug":"HEXO添加字数统计、阅读时长","date":"2018-01-25T05:26:26.000Z","updated":"2018-01-25T12:31:25.370Z","comments":true,"path":"2018/01/25/HEXO添加字数统计、阅读时长/","link":"","permalink":"http://www.ariesjch.top/2018/01/25/HEXO添加字数统计、阅读时长/","excerpt":"插件安装首先需要安装插件hexo-wordcount，执行如下命令安装：npm i --save hexo-wordcount如果Node的版本在7.6.0之前，请安装2.x版本，执行如下命令：npm install hexo-wordcount@2 --save","text":"插件安装首先需要安装插件hexo-wordcount，执行如下命令安装：npm i --save hexo-wordcount如果Node的版本在7.6.0之前，请安装2.x版本，执行如下命令：npm install hexo-wordcount@2 --save 配置说明NexT主题中已经集成好了文章的字数统计、阅读时长的统计功能。我们只需要在/themes/next/_config.yml中打开相应的统计功能即可。配置如下：12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true # 单篇 字数统计 min2read: true # 单篇 阅读时长 totalcount: false # 网站 字数统计 #separated_meta: true 修改完成后，预览hexo s即可。 显示文字打开文件/themes/next/layout/_macro/post.swig修改字数统计,找到如下代码进行修改：123&lt;span title=\"&#123;&#123; __('post.wordcount') &#125;&#125;\"&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字&lt;/span&gt; 然后修改阅读时长,找到如下代码进行修改：123&lt;span title=\"&#123;&#123; __('post.min2read') &#125;&#125;\"&gt; &#123;&#123; min2read(post.content) &#125;&#125; 分钟&lt;/span&gt; 效果展示","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.ariesjch.top/tags/hexo/"}]},{"title":"非结构化数据挖掘","slug":"非结构化数据挖掘","date":"2018-01-20T06:43:56.000Z","updated":"2018-01-25T12:31:28.333Z","comments":true,"path":"2018/01/20/非结构化数据挖掘/","link":"","permalink":"http://www.ariesjch.top/2018/01/20/非结构化数据挖掘/","excerpt":"学习链接： https://wenku.baidu.com/view/b4267f42ff00bed5b8f31d50.html 文本挖掘文本挖掘的主要目标是获得文本的主要内容特征，如文本涉及的主题、文本主题的类属、文本内容的浓缩等。 文本挖掘的具体实现技术主要有如下几种：","text":"学习链接： https://wenku.baidu.com/view/b4267f42ff00bed5b8f31d50.html 文本挖掘文本挖掘的主要目标是获得文本的主要内容特征，如文本涉及的主题、文本主题的类属、文本内容的浓缩等。 文本挖掘的具体实现技术主要有如下几种： 文本挖掘的主要应用目前文本挖掘处理主要集中于信息自动导航、可视化信息检索、信息提取、信息分类、文本聚类等。 处理过程 文本表示与预处理 文本表示 文本表示是指用文本的特征信息集合来代表原来的文本。文本的特征信息是关于文本的元数据，可以分为外部特征和内部特征两种类型。文本的外部特征包括文本的名称、日期、大小、类型、文本的作者、标题和机构等信息。文本的内部特征包括主题、分类、摘要等信息。 文本的表示方法主要采用向量空间模型(VSM) 向量空间模型主要用于文本内容特征的表示，一般使用词来表示文本的特征信息，我们称每个词为一个特征项。向量空间模型的基本思想是以向量(W1, W2, …, Wn)来表示文本，其中Wi为第i个特征项的权重。可以选择字、词或者词组作为特征项。 通常选择词作为特征项，并使用词频来表示特征项对应的分量。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://www.ariesjch.top/tags/深度学习/"}]},{"title":"C++复制构造函数","slug":"C-复制构造函数","date":"2018-01-15T01:09:50.000Z","updated":"2018-01-25T12:31:24.988Z","comments":true,"path":"2018/01/15/C-复制构造函数/","link":"","permalink":"http://www.ariesjch.top/2018/01/15/C-复制构造函数/","excerpt":"构造函数是干什么的？该类对象被创建时，编译系统对象分配内存空间，并自动调用该构造函数，由构造函数完成成员的初始化工作。所以，构造函数的作用是初始化对象的数据成员。 构造函数的种类","text":"构造函数是干什么的？该类对象被创建时，编译系统对象分配内存空间，并自动调用该构造函数，由构造函数完成成员的初始化工作。所以，构造函数的作用是初始化对象的数据成员。 构造函数的种类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Complex &#123; private : double m_real; double m_imag; public: // 无参数构造函数 // 如果创建一个类你没有写任何构造函数,则系统会自动生成默认的无参构造函数，函数为空，什么都不做 // 只要你写了一个下面的某一种构造函数，系统就不会再自动生成这样一个默认的构造函数，如果希望有一个这样的无参构造函数，则需要自己显示地写出来 Complex(void) &#123; m_real = 0.0; m_imag = 0.0; &#125; // 一般构造函数（也称重载构造函数） // 一般构造函数可以有各种参数形式,一个类可以有多个一般构造函数，前提是参数的个数或者类型不同（基于c++的重载函数原理） // 例如：你还可以写一个 Complex( int num)的构造函数出来 // 创建对象时根据传入的参数不同调用不同的构造函数 Complex(double real, double imag) &#123; m_real = real; m_imag = imag; &#125; // 复制构造函数（也称为拷贝构造函数） // 复制构造函数参数为类对象本身的引用，用于根据一个已存在的对象复制出一个新的该类的对象，一般在函数中会将已存在对象的数据成员的值复制一份到新创建的对象中 // 若没有显示的写复制构造函数，则系统会默认创建一个复制构造函数，但当类中有指针成员时，由系统默认创建该复制构造函数会存在风险，具体原因请查询有关 “浅拷贝” 、“深拷贝”的文章论述 Complex(const Complex &amp; c) &#123; // 将对象c中的数据成员值复制过来 m_real = c.m_real; m_img = c.m_img; &#125; // 类型转换构造函数，根据一个指定的类型的对象创建一个本类的对象 // 例如：下面将根据一个double类型的对象创建了一个Complex对象 Complex::Complex(double r) &#123; m_real = r; m_imag = 0.0; &#125; // 等号运算符重载 // 注意，这个类似复制构造函数，将=右边的本类对象的值复制给等号左边的对象，它不属于构造函数，等号左右两边的对象必须已经被创建 // 若没有显示的写=运算符重载，则系统也会创建一个默认的=运算符重载，只做一些基本的拷贝工作 Complex &amp;operator=(const Complex &amp;rhs) &#123; // 首先检测等号右边的是否就是左边的对象本，若是本对象本身,则直接返回 if ( this == &amp;rhs ) &#123; return *this; &#125; // 复制等号右边的成员到左边的对象中 this-&gt;m_real = rhs.m_real; this-&gt;m_imag = rhs.m_imag; // 把等号左边的对象再次传出 // 目的是为了支持连等 eg: a=b=c 系统首先运行 b=c // 然后运行 a= ( b=c的返回值,这里应该是复制c值后的b对象) return *this; &#125;&#125;; 什么情况使用复制构造函数？ 一个对象以值传递的方式传入函数体 一个对象以值传递的方式从函数返回 一个对象需要通过另外一个对象进行初始化 深拷贝与浅拷贝 浅拷贝：在对象复制时，只对对象中的数据成员进行简单的赋值，默认拷贝构造函数执行的也是浅拷贝。在“深拷贝”的情况下，对于对象中动态成员，就不能仅仅简单地赋值了，而应该重新动态分配空间 深拷贝：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.ariesjch.top/tags/C/"}]},{"title":"VBA学习笔记（二）","slug":"VBA学习笔记（二）","date":"2018-01-11T04:49:53.000Z","updated":"2018-01-25T12:31:27.024Z","comments":true,"path":"2018/01/11/VBA学习笔记（二）/","link":"","permalink":"http://www.ariesjch.top/2018/01/11/VBA学习笔记（二）/","excerpt":"1. 数据类型1.1 数据类型定义模式1234567' 变量类型定义Dim productionName As StringDim length As IntergerDim reg As RegExpPublic Function MsgBox(msg As String)Public Function len(s As String) As Long 1.2 实例 定义一个函数，要求接收两个字符串，并返回较长的那一个长度","text":"1. 数据类型1.1 数据类型定义模式1234567' 变量类型定义Dim productionName As StringDim length As IntergerDim reg As RegExpPublic Function MsgBox(msg As String)Public Function len(s As String) As Long 1.2 实例 定义一个函数，要求接收两个字符串，并返回较长的那一个长度","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"VBA","slug":"VBA","permalink":"http://www.ariesjch.top/tags/VBA/"}]},{"title":"VBA学习笔记（一）","slug":"VBA学习笔记（一）","date":"2018-01-11T04:33:52.000Z","updated":"2018-01-25T12:31:26.925Z","comments":true,"path":"2018/01/11/VBA学习笔记（一）/","link":"","permalink":"http://www.ariesjch.top/2018/01/11/VBA学习笔记（一）/","excerpt":"1.1 初识 VBA打开VBA,启动快捷键Alt+F11 1.2 立即窗口VBA编辑器（VBE）启动后，请设置立即窗口为开启状态。 视图 =&gt; 立即窗口 快捷键：Ctrl+G 尝试如下命令：12? 1 + 1? len(\"qiou.eu\")","text":"1.1 初识 VBA打开VBA,启动快捷键Alt+F11 1.2 立即窗口VBA编辑器（VBE）启动后，请设置立即窗口为开启状态。 视图 =&gt; 立即窗口 快捷键：Ctrl+G 尝试如下命令：12? 1 + 1? len(\"qiou.eu\") 1.3 建立第一个项目在工程窗口中右击，选择插入 =&gt; 模块，此时默认名称为“模块1”，在名称栏将“模块1”更名为“Main”（注意将M大写） 在右方主窗口输入如下代码：12345678Option ExplictPublic Sub Main() helloworldEnd SubPrivate Function helloworld() MsgBox \"hello, world!\"End Function 输入完毕后，将光标放到Main函数括号后面，然后运行 MsgBox函数介绍: 在对话框中显示消息，等待用户单击按钮，并返回指示用户单击的按钮的整数。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"VBA","slug":"VBA","permalink":"http://www.ariesjch.top/tags/VBA/"}]},{"title":"NPC、NP、P问题","slug":"NPC-NP-P问题","date":"2018-01-08T06:47:02.000Z","updated":"2018-01-25T12:31:25.999Z","comments":true,"path":"2018/01/08/NPC-NP-P问题/","link":"","permalink":"http://www.ariesjch.top/2018/01/08/NPC-NP-P问题/","excerpt":"","text":"","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"http://www.ariesjch.top/tags/算法设计与分析/"}]},{"title":"常见排序时间复杂度","slug":"常见排序时间复杂度","date":"2018-01-05T10:10:36.000Z","updated":"2018-01-25T12:31:27.649Z","comments":true,"path":"2018/01/05/常见排序时间复杂度/","link":"","permalink":"http://www.ariesjch.top/2018/01/05/常见排序时间复杂度/","excerpt":"","text":"","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"http://www.ariesjch.top/tags/算法设计与分析/"}]},{"title":"【分治法】 快速排序","slug":"分治法-快速排序","date":"2018-01-05T08:48:21.000Z","updated":"2018-01-25T12:31:27.362Z","comments":true,"path":"2018/01/05/分治法-快速排序/","link":"","permalink":"http://www.ariesjch.top/2018/01/05/分治法-快速排序/","excerpt":"问题描述分治法实现快速排序 思路两次扫描法确定分区：初选第一个元素为初始的分裂点，其他点与初始分裂点比较，以确定最后的分裂点。","text":"问题描述分治法实现快速排序 思路两次扫描法确定分区：初选第一个元素为初始的分裂点，其他点与初始分裂点比较，以确定最后的分裂点。 两次扫描： 从左到右扫描一次，从第2个元素开始，逐个与初始分裂点（也就是第一个元素比较），直到遇到大于或等于分裂点的元素为止。 从右到做扫描一次，从最后一个元素开始，逐个与初始分裂点（也就是第一个元素比较），直到遇到小于或等于分裂点的元素为止。 根据两次扫描的结果，观察扫描指针是否相交。 未相交： 相交： 直到相交后，找到了分裂点，即 j扫描指针的位置。 将 arr[j]元素与初始分裂点元素交换位置。返回新分裂点的位置（j）。 找到新的分裂点后，在分裂点左右继续递归进行排序，QuickSort(arr, left, j - 1), QuickSort(arr, j + 1, right)。 核心代码完整代码查看 github: https://github.com/ariescc/Algorithm/blob/master/all/%E5%88%86%E6%B2%BB%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/QuickSort.cpp 寻找分裂点： 1234567891011121314151617181920212223242526272829// 寻找分裂点int partition(int *arr, int left, int right)&#123; int p = arr[left]; // 设定最初的分裂点为第一个元素 int i = left + 1, j = right; while(true) &#123; // i 从左向右扫描，直到找到第一个大于等于分裂点值的元素 while(arr[i] &lt; p &amp;&amp; i &lt;= right) &#123; i++; &#125; // j 从右向左扫描，直到找到第一个小于等于分裂点值的元素 while(arr[j] &gt; p &amp;&amp; j &gt;= left) &#123; j--; &#125; // 如果 i 和 j相交 if(i &gt;= j) &#123; break; &#125; swap(arr[i], arr[j]); // 不相交的话交换两个位置的元素 &#125; swap(arr[left], arr[j]); // 交换 j 和 最初位置的元素 return j;&#125; 分裂点左右递归进行快排： 123456789void QuickSort(int *arr, int left, int right)&#123; if(left &lt; right) &#123; int q = partition(arr, left, right); // 寻找分裂点 // 在分裂点两遍继续递归排序 QuickSort(arr, left, q - 1); // 分裂点左面 QuickSort(arr, q + 1, right); // 分裂点右面 &#125;&#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"http://www.ariesjch.top/tags/算法设计与分析/"}]},{"title":"【分治法】 合并排序","slug":"分治法-合并排序","date":"2018-01-05T07:40:36.000Z","updated":"2018-01-25T12:31:27.286Z","comments":true,"path":"2018/01/05/分治法-合并排序/","link":"","permalink":"http://www.ariesjch.top/2018/01/05/分治法-合并排序/","excerpt":"问题分治法实现合并排序 思路将待排序序列分解成单个元素，然后对单个元素进行合并，并且在合并的过程中将分割区间分别置入左右两个数组中Left[],Right[]。然后对两个数组模拟队列，每次取出两个队首的较小元素放入合并数组arr中。","text":"问题分治法实现合并排序 思路将待排序序列分解成单个元素，然后对单个元素进行合并，并且在合并的过程中将分割区间分别置入左右两个数组中Left[],Right[]。然后对两个数组模拟队列，每次取出两个队首的较小元素放入合并数组arr中。 按照分治法，最终将整个序列分解到唯一的元素（无法继续分解为止），从单个元素的基础上进行合并，能够保证每次左右两个数组是有序的。 归并代码执行过程如序号所示： 核心代码完整代码参看 github: https://github.com/ariescc/Algorithm/blob/master/all/%E5%88%86%E6%B2%BB%E6%B3%95/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F/mergeSort.cpp 合并排序的主要步骤为两部，一是进行区间分割，然后分割到不可继续分割的子元素为止，然后进行元素合并。 递归进行区间分割： 12345678910111213/**将序列分解，直到分解为单元素*/void MergeSort(int *arr, int p, int r)&#123; // 序列左右边界未重合，则该段序列一直分解 if(p &lt; r) &#123; int q = (p + r) &gt;&gt; 1; // 取中间，将该段区间分为两部分 MergeSort(arr, p, q); // 分解左半段区间 MergeSort(arr, q+1, r); // 分解右半段区间 Merge(arr, p, q, r); // 合并 p ~ r 区间的单元素，并排序 &#125;&#125; 子问题合并： 12345678910111213141516171819202122232425262728293031// p 区间左边界，r 区间右边界， q 为 p,r 中间分割位置void Merge(int *arr, int p, int q, int r)&#123; int len1 = q - p + 1; // 左端区间长度 int len2 = r - q; // 右段区间长度 int *Left = new int[len1 + 1]; int *Right = new int[len2 + 1]; Left[len1] = MAX_NUM; Right[len2] = MAX_NUM; // 将左区间的元素置入 Left数组中 for(int i = 0; i &lt; len1; i++) &#123; Left[i] = arr[p + i]; &#125; // 将右区间的元素置入 Right数组中 for(int j = 0; j &lt; len2; j++) &#123; Right[j] = arr[q + j + 1]; &#125; int i = 0, j = 0; // 左右区间 Left 和 Right 数组元素比较大小，置入 arr数组 for(int k = p; k &lt;= r; k++) &#123; if(Left[i] &lt; Right[j]) &#123; arr[k] = Left[i]; i++; &#125; else &#123; arr[k] = Right[j]; j++; &#125; &#125;&#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"http://www.ariesjch.top/tags/算法设计与分析/"}]},{"title":"【分治法】 二分查找","slug":"分治法-二分查找","date":"2018-01-04T09:48:50.000Z","updated":"2018-01-25T12:31:27.180Z","comments":true,"path":"2018/01/04/分治法-二分查找/","link":"","permalink":"http://www.ariesjch.top/2018/01/04/分治法-二分查找/","excerpt":"问题描述在给定升序序列中查找到给定元素，并返回该元素的下标。 思路把有序的序列分为两部分，然后取中间元素与target进行比较，如果相等则返回当前位置下标。如果 中间元素 &lt; target，在右半部分继续进行查找，left = mid。如果中间元素 &gt; target，在左半部分继续进行查找，right = mid。直到 left == right, 缩小到一个元素位置范围，不能继续分解，停止查找，如果没有查找到返回-1。","text":"问题描述在给定升序序列中查找到给定元素，并返回该元素的下标。 思路把有序的序列分为两部分，然后取中间元素与target进行比较，如果相等则返回当前位置下标。如果 中间元素 &lt; target，在右半部分继续进行查找，left = mid。如果中间元素 &gt; target，在左半部分继续进行查找，right = mid。直到 left == right, 缩小到一个元素位置范围，不能继续分解，停止查找，如果没有查找到返回-1。 核心代码完整代码查看 github： https://github.com/ariescc/Algorithm/blob/master/all/%E5%88%86%E6%B2%BB%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/binarySearch.cpp 1234567891011121314151617int binarySearch(int *arr, int len, int target)&#123; int left = 0, mid, right = len - 1; while(left &lt;= right) &#123; mid = (left + right) &gt;&gt; 1; if(arr[mid] == target) &#123; return mid; &#125; else if(arr[mid] &lt; target) &#123; left = mid; &#125; else if(arr[mid] &gt; target) &#123; right = mid; &#125; &#125; return -1;&#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"http://www.ariesjch.top/tags/算法设计与分析/"}]},{"title":"【分治法】 整数划分问题","slug":"分治法-整数划分问题","date":"2018-01-04T08:36:04.000Z","updated":"2018-01-25T12:31:27.432Z","comments":true,"path":"2018/01/04/分治法-整数划分问题/","link":"","permalink":"http://www.ariesjch.top/2018/01/04/分治法-整数划分问题/","excerpt":"问题描述将正整数n表示成一系列正整数之和，求正整数n的不同划分个数。 思路使用分治法解决。 如将n=6划分： q(n, m) 表示将正整数n进行划分，并且最大的加数不超过m。","text":"问题描述将正整数n表示成一系列正整数之和，求正整数n的不同划分个数。 思路使用分治法解决。 如将n=6划分： q(n, m) 表示将正整数n进行划分，并且最大的加数不超过m。 当 n == 1：m取任意的正整数，1只能表示为 {1}，只有1种划分方法。 当 m == 1：n只有1种划分方法。(如n==2，划分为{1, 1}) 当 n == m：考虑划分中是否包含n，包含如下情况： 划分中包含 n，则只有1种划分{n} 划分中不包含n，那么划分中最大的加数一定比n小，即按照最大加数为n-1继续进行划分 当前划分数表示为 1 + q(n, n - 1) 当 n &lt; m：实际不存在 n &lt; m的情况，此时等同于 q(n, n) 当 n &gt; m：考虑划分中是否包含最大加数m，包含如下情况： 包含m：{m, {x1, x2, x3, …} }，并且x1+x2+x3+…. = n-m，此时划分数为 q(n-m, m)。如q(12, 4)，划分加数最大为4，q(12, 4)划分为{4, {8}}，当前划分数其实为{8}划分数为多少（以最大划分加数为4进行划分q(8, 4)）。 划分中不包含m，并且所有划分加数均比m小，即将n按照最大加数为m-1进行划分，表示为q(n, m-1)。 核心代码完整代码参照 github: https://github.com/ariescc/Algorithm/blob/master/all/%E5%88%86%E6%B2%BB%E6%B3%95/%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86/zshf.cpp 12345678910111213141516int zshf(int n, int m)&#123; if((n == 1) || (m == 1)) &#123; return 1; &#125; if(n == m) &#123; return 1 + zshf(n, n - 1); &#125; else if(n &lt; m) &#123; return zshf(n, n); &#125; else if(n &gt; m) &#123; return zshf(n - m, m) + zshf(n, m - 1); &#125;&#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"http://www.ariesjch.top/tags/算法设计与分析/"}]},{"title":"【分治法】 全排列问题","slug":"分治法-全排列问题","date":"2018-01-04T07:50:38.000Z","updated":"2018-01-25T12:31:27.220Z","comments":true,"path":"2018/01/04/分治法-全排列问题/","link":"","permalink":"http://www.ariesjch.top/2018/01/04/分治法-全排列问题/","excerpt":"问题描述R由n个元素构成的序列集合，求R的全排列。 思路此题是分治法应用。依次将待排列的数组的后n-1个元素与第一个元素交换（递归操作），每次递归处理的都是后n-1个元素的全排列。不断递归，直到递归分解到不可分解的子问题，到只有一个元素，然后输出当前排列。","text":"问题描述R由n个元素构成的序列集合，求R的全排列。 思路此题是分治法应用。依次将待排列的数组的后n-1个元素与第一个元素交换（递归操作），每次递归处理的都是后n-1个元素的全排列。不断递归，直到递归分解到不可分解的子问题，到只有一个元素，然后输出当前排列。 核心代码完整代码参照 github: https://github.com/ariescc/Algorithm/blob/master/all/%E5%88%86%E6%B2%BB%E6%B3%95/%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/quanpailie.cpp 123456789101112131415161718void qpl(int *arr, int k, int sz)&#123; // 不能再分解为更小的子结构时输出 if(k == sz) &#123; for(int i = 0; i &lt;= sz; i++) &#123; printf(\"%d \", arr[i]); &#125; printf(\"\\n\"); return; &#125; else &#123; for(int i = k; i &lt;= sz; i++) &#123; swap(arr[i], arr[k]); qpl(arr, k + 1, sz); swap(arr[i], arr[k]); &#125; &#125;&#125; 模拟过程从 qpl(arr, 0, n - 1) 开始递归(如 n = 2) arr(1, 2) k = 0, sz = n - 1 = 1else -&gt; i = k = 0, swap(0, 0), arr(1, 2, 3), qpl(arr, k+1 = 1, sz = 1) -&gt; qpl(arr, 1, 1), k == sz, ouput =&gt; “1, 2” -&gt; return -&gt; qpl(arr, 0, sz), i = 1, k = 0 -&gt; swap(1, 2) -&gt; arr(2, 1) -&gt; qpl(arr, k+1 = 1, 1) -&gt; k == sz -&gt; output =&gt; “2, 1” -&gt; return -&gt; 递归结束","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"http://www.ariesjch.top/tags/算法设计与分析/"}]},{"title":"判断日期 正则表达式","slug":"判断日期-正则表达式","date":"2018-01-01T09:45:42.000Z","updated":"2018-01-25T12:31:27.476Z","comments":true,"path":"2018/01/01/判断日期-正则表达式/","link":"","permalink":"http://www.ariesjch.top/2018/01/01/判断日期-正则表达式/","excerpt":"java 判断日期的正则表达式： 12345678910111213141516public boolean isDate(String date) &#123; /** * 判断日期格式和范围 */ String rexp = \"^((\\\\d&#123;2&#125;(([02468][048])|([13579][26]))[\\\\-\\\\/\\\\s]?((((0?[13578])|(1[02]))[\\\\-\\\\/\\\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\\\-\\\\/\\\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\\\-\\\\/\\\\s]?((0?[1-9])|([1-2][0-9])))))|(\\\\d&#123;2&#125;(([02468][1235679])|([13579][01345789]))[\\\\-\\\\/\\\\s]?((((0?[13578])|(1[02]))[\\\\-\\\\/\\\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\\\-\\\\/\\\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\\\-\\\\/\\\\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))\"; Pattern pat = Pattern.compile(rexp); Matcher mat = pat.matcher(date); boolean dateType = mat.matches(); return dateType; &#125;","text":"java 判断日期的正则表达式： 12345678910111213141516public boolean isDate(String date) &#123; /** * 判断日期格式和范围 */ String rexp = \"^((\\\\d&#123;2&#125;(([02468][048])|([13579][26]))[\\\\-\\\\/\\\\s]?((((0?[13578])|(1[02]))[\\\\-\\\\/\\\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\\\-\\\\/\\\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\\\-\\\\/\\\\s]?((0?[1-9])|([1-2][0-9])))))|(\\\\d&#123;2&#125;(([02468][1235679])|([13579][01345789]))[\\\\-\\\\/\\\\s]?((((0?[13578])|(1[02]))[\\\\-\\\\/\\\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\\\-\\\\/\\\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\\\-\\\\/\\\\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))\"; Pattern pat = Pattern.compile(rexp); Matcher mat = pat.matcher(date); boolean dateType = mat.matches(); return dateType; &#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.ariesjch.top/tags/java/"}]},{"title":"Date 比较大小","slug":"Date-比较大小","date":"2018-01-01T09:41:35.000Z","updated":"2018-01-25T12:31:25.030Z","comments":true,"path":"2018/01/01/Date-比较大小/","link":"","permalink":"http://www.ariesjch.top/2018/01/01/Date-比较大小/","excerpt":"","text":"java 两个日期比较大小： 日期的格式 yyyy-MM-dd 123456789101112String startTime = \"2018-01-01\";String endTime = \"2018-01-02\";DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");Date dt1 = df.parse(startTime);Date dt2 = df.parse(endTime);if(dt1.before(dt2)) &#123; ...&#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.ariesjch.top/tags/java/"}]},{"title":"ArrayList 删除指定元素","slug":"ArrayList-删除指定元素","date":"2018-01-01T09:34:20.000Z","updated":"2018-01-25T12:31:23.816Z","comments":true,"path":"2018/01/01/ArrayList-删除指定元素/","link":"","permalink":"http://www.ariesjch.top/2018/01/01/ArrayList-删除指定元素/","excerpt":"遍历ArrayList，删除指定元素： 12MatterTable.removeIf(matter -&gt; Integer.parseInt(matter.userId) == userId);","text":"遍历ArrayList，删除指定元素： 12MatterTable.removeIf(matter -&gt; Integer.parseInt(matter.userId) == userId); 或 12345678Iterator&lt;Matter&gt; iterator = MatterTable.iterator();while(iterator.hasNext()) &#123; Matter matter = iterator.next(); if(matter == xxx) &#123; matter.remove(); &#125;&#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.ariesjch.top/tags/java/"}]},{"title":"String substring()","slug":"String-substring-1","date":"2017-11-30T13:12:37.000Z","updated":"2018-01-25T12:31:26.866Z","comments":true,"path":"2017/11/30/String-substring-1/","link":"","permalink":"http://www.ariesjch.top/2017/11/30/String-substring-1/","excerpt":"一：String.substring(int start) 参数： start：要截取位置的索引 返回： 从start开始到结束的字符串","text":"一：String.substring(int start) 参数： start：要截取位置的索引 返回： 从start开始到结束的字符串 例如：String str = “hello word!”; System.out.println(str.substring(1)); System.out.println(str.substring(3)); System.out.println(str.substring(6)); 将得到结果为： ello word! lo word! ord! 如果start大于字符串的长度将会抛出越界异常； 二：String.substring(int beginIndex, int endIndex) 参数： beginIndex 开始位置索引 endIndex 结束位置索引 返回： 从beginIndex位置到endIndex位置内的字符串 例如：String str = “hello word!”; System.out.println(str.substring(1,4)); System.out.println(str.substring(3,5)); System.out.println(str.substring(0,4)); 将得到结果为： ell lo hell 如果startIndex和endIndex其中有越界的将会抛出越界异常。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.ariesjch.top/tags/java/"}]},{"title":"String indexOf()","slug":"String-indexOf","date":"2017-11-30T13:12:09.000Z","updated":"2018-01-25T12:31:26.819Z","comments":true,"path":"2017/11/30/String-indexOf/","link":"","permalink":"http://www.ariesjch.top/2017/11/30/String-indexOf/","excerpt":"int indexOf(int ch,int fromIndex)函数：就是字符ch在字串fromindex位后出现的第一个位置.没有找到返加-1","text":"int indexOf(int ch,int fromIndex)函数：就是字符ch在字串fromindex位后出现的第一个位置.没有找到返加-1","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.ariesjch.top/tags/java/"}]},{"title":"InputStream 的三个read的区别","slug":"InputStream-的三个read的区别","date":"2017-11-30T12:47:42.000Z","updated":"2018-01-25T12:31:25.436Z","comments":true,"path":"2017/11/30/InputStream-的三个read的区别/","link":"","permalink":"http://www.ariesjch.top/2017/11/30/InputStream-的三个read的区别/","excerpt":"read 这个方法是对这个流一个一个字节的读，返回的int就是这个字节的int表示方式以下是代码片段，经过测试当eclipse的编码为gbk时，转化出的字符串不需经过重新编码，如果eclipse的编码为utf-8时则由byte转成字符串需重新编成utf-8的","text":"read 这个方法是对这个流一个一个字节的读，返回的int就是这个字节的int表示方式以下是代码片段，经过测试当eclipse的编码为gbk时，转化出的字符串不需经过重新编码，如果eclipse的编码为utf-8时则由byte转成字符串需重新编成utf-8的 1234567891011InputStream in = Test.class.getResourceAsStream(\"/tt.txt\");byte[]tt=new byte[15];//测试用的事前知道有15个字节码while(in.available()!=0)&#123;for(int i=0;i&lt;15;i++)&#123;tt[i]=(byte)in.read();&#125;&#125;String ttttt=new String(tt,\"utf-8\");System.out.println(ttttt);in.close(); read(byte[] b) 这个方法是先规定一个数组长度，将这个流中的字节缓冲到数组b中，返回的这个数组中的字节个数，这个缓冲区没有满的话，则返回真实的字节个数，到未尾时都返回-1123456789in = Test.class.getResourceAsStream(\"/tt.txt\");byte [] tt=new byte[1024];int b;while((b=in.read(tt))!=-1)&#123;System.out.println(b);String tzt=new String(tt,\"utf-8\");System.out.println(tzt); read(byte[] b, int off, int len)此方法其实就是多次调用了read()方法12345678InputStream in = Test.class.getResourceAsStream(\"/tt.txt\");//System.out.println(in.available());//此方法是返回这个流中有多少个字节数，可以把数组长度定为这个byte[]tt=new byte[in.available()];int z;while((z=in.read(tt, 0, tt.length))!=-1)&#123;System.out.println(new String(tt,\"utf-8\"));&#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.ariesjch.top/tags/java/"}]},{"title":"socket 和 serversocket","slug":"socket-和-serversocket","date":"2017-11-30T03:25:44.000Z","updated":"2018-01-25T12:31:26.741Z","comments":true,"path":"2017/11/30/socket-和-serversocket/","link":"","permalink":"http://www.ariesjch.top/2017/11/30/socket-和-serversocket/","excerpt":"ServerSocket类创建一个ServerSocket类，同时在运行该语句的计算机的指定端口处建立一个监听服务。如:1ServerSocket MyListener = new ServerSocket(600);","text":"ServerSocket类创建一个ServerSocket类，同时在运行该语句的计算机的指定端口处建立一个监听服务。如:1ServerSocket MyListener = new ServerSocket(600); 这里指定提供监听服务的端口是600，一台计算机可以同时提供多个服务，这些不同的服务之间通过端口号来区别，不同的端口号上提供不同的服务。为了随时监听可能的Client请求，执行如下语句：1Socket LinkSocket = MyListener.accpet(); 该语句调用了ServerSocket对象的accept()方法，这个方法的执行将使Server端的程序处于等待状态，程序将一直阻塞直到捕捉到一个来自Client端的请求，并返回一个用于与该Client通信的Socket对象LinkSocket。之后Server程序只要向这个Socket对象读写数据，就可以实现向远端的Client读写数据。 结束监听时，关闭ServerSocket对象：1MyListener.close(); Socket类当Client程序需要从Server端获取信息及其他服务时，应创建一个Socket对象：1Socket MySocket = new Socket(\"ServerComputerName\", 600); Socket类的构造函数有两个参数，第一个参数是欲连接到的Server计算机的主机地址，第二个参数是该Server机上提供服务的端口号。 Socket对象建立成功后，就可以在Client和Server之间建立一个连接，并通过这个连接在两个端点之间传递数据。利用Socket类的方法getOutputStream() 和 getInputStream() 分别获得向Socket读写数据的输入/输出流，最后将从Server端读取的数据重新返还到Server端。 当Server端和Client端的通信结束时，可以调用Socket类的close()方法关闭Socket，拆除连接。 ServerSocket 一般仅用于设置端口号和监听，真正进行通信的是服务器端的Socket与客户端的Socket，在ServerSocket进行accpet后，就将主动权转让了。 服务器端程序设计在服务器端，利用ServerSocket类的构造函数ServerSocket(int port)创建一个ServerSocket类的对象，port参数传递端口，这个端口就是服务器监听连接请求的端口，如果在这时出现错误将抛出IOException异常对象，否则将创建ServerSocket对象并开始准备接收连接请求。 服务程序从调用ServerSocket的accept()方法开始，直到连接建立。在建立连接后，accept()返回一个创建的Socket对象，该Socket对象绑定了客户端的IP地址或端口号。 客户端程序设计当客户端程序需要与服务器端程序通信时，需要在客户机创建一个Socket对象。Socket类有构造函数Socket(InetAddress addr, int port) 和 Socket(String host, int port)，两个构造函数都创建了一个基于Socket的连接服务器端流套接字的流套接字。对于第一个InetAddress子类对象通过addr参数获得服务器主机的IP地址，对于第二个函数host参数包被分配到InetAddress对象中，如果没有IP地址与host参数相一致，那么将抛出UnknownHostException异常对象。两个函数都通过参数port获得服务器的端口号。假设已经建立连接了，网络API将在客户端基于Socket的流套接字中捆绑客户端程序的IP地址和任意一个端口号，否则两个函数都会抛出一个IOException对象。 如果创建了一个Socket对象，那么它可通过getInputStream()方法从服务端程序获得输入流读传来的消息，也可通过调用getOutputStream()方法获得输出流来发送消息。在读写活动完成之后，客户端程序调用close()方法关闭流和流套接字。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"socket编程","slug":"socket编程","permalink":"http://www.ariesjch.top/tags/socket编程/"}]},{"title":"jquery.form.js 实现文件上传","slug":"jquery-form-js-实现文件上传","date":"2017-11-19T11:28:45.000Z","updated":"2018-01-25T12:31:25.856Z","comments":true,"path":"2017/11/19/jquery-form-js-实现文件上传/","link":"","permalink":"http://www.ariesjch.top/2017/11/19/jquery-form-js-实现文件上传/","excerpt":"使用 jquery.form.js 实现文件上传前端","text":"使用 jquery.form.js 实现文件上传前端 1234567891011121314151617181920212223@&#123; ViewBag.Title = \"Upload\";&#125;&lt;form enctype=\"multipart/form-data\" method=\"post\" id=\"upload\"&gt; &lt;input type=\"file\" id=\"fileupload\" name=\"Upload\" /&gt; @* button 而不是 submit *@ &lt;input type=\"button\" value=\"上传\" id=\"btn\"&gt;&lt;/form&gt;&lt;script&gt; $(\"#btn\").click(function () &#123; $(\"#upload\").ajaxSubmit(&#123; url: \"/Doc/UploadDoc\", type: \"post\", success: function (data) &#123; console.log(data); &#125;, error: function (aa) &#123; console.log(aa); &#125; &#125;); &#125;);&lt;/script&gt; .ajaxSubmit 是 jquery.form.js 里的方法。ajaxSubmit 中的 url 参数中使用 Controller 中的方法，上面代码在提交表单调用的方法是 DocController 中 UploadDoc 方法。 后端1234567891011121314151617181920212223242526272829303132333435363738394041424344public class DocController : Controller&#123; [HttpPost] public JsonResult UploadFile() &#123; HttpPostFileBase file = Request.Files[0]; if(file != null) &#123; string fileName = Path.GetFileName(file.FileName); string fileExt = Path.GetExtension(file.FileName); string fileSaveDir = server.MapPath(\"~/upload\"); if(!Directory.Exists(fileSaveDir)) &#123; Directory.CreateDirectory(fileSaveDir); &#125; file.SaveAs(Path.Combine(fileSaveDir, fileName)); // 如果表单有其他项，在此处写提交逻辑 return new JsonResult &#123; Data = new &#123; _code = 200, _msg = \"上传成功\", _data = new &#123; _url = \"/upload/\" + fileNewName, _oldName = fileName &#125; &#125;, JsonRequestBehavior = JsonRequestBehavior.DenyGet &#125;; &#125; return new JsonResult &#123; Data = new &#123; _code = 200, _msg = \"上传失败\" &#125;, JsonRequestBehavior = JsonRequestBehavior.DenyGet &#125;; &#125;&#125; jquery.form.js 下载地址https://malsup.github.io/jquery.form.js","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"asp.net mvc","slug":"asp-net-mvc","permalink":"http://www.ariesjch.top/tags/asp-net-mvc/"}]},{"title":"53. Maximum Subarray ac 题解","slug":"53-Maximum-Subarray-ac-题解","date":"2017-11-19T03:30:43.000Z","updated":"2018-01-25T12:31:23.280Z","comments":true,"path":"2017/11/19/53-Maximum-Subarray-ac-题解/","link":"","permalink":"http://www.ariesjch.top/2017/11/19/53-Maximum-Subarray-ac-题解/","excerpt":"题意给定一数组，求连续元素之和的最大值。 input:[-2 1 3 4 -1 2 1 -5 4] output:6","text":"题意给定一数组，求连续元素之和的最大值。 input:[-2 1 3 4 -1 2 1 -5 4] output:6 题解动态规划 上面样例当 [4 -1 2 1] 连续元素和的值最大。 dp[i] = max(nums[i], dp[i-1] + nums[i]) 代码（C++）1234567891011121314151617181920212223class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; dp; dp.push_back(nums[0]); if(!nums.size()) return 0; for(int i = 1; i &lt; nums.size(); i++) &#123; dp[i] = max(nums[i], dp[i-1] + nums[i]); dp.push_back(dp[i]); &#125; int maxium = dp[0]; for(int i = 0; i &lt; dp.size(); i++) &#123; if(dp[i] &gt; maxium) &#123; maxium = dp[i]; &#125; &#125; return maxium; &#125;&#125;;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.ariesjch.top/tags/leetcode/"}]},{"title":"283. Move Zeroes 题解","slug":"283-Move-Zeroes-题解","date":"2017-11-12T12:20:37.000Z","updated":"2018-01-25T12:31:23.181Z","comments":true,"path":"2017/11/12/283-Move-Zeroes-题解/","link":"","permalink":"http://www.ariesjch.top/2017/11/12/283-Move-Zeroes-题解/","excerpt":"题解给定一个数组，数组中包含着若干个0，要求在保证非0元素在vector中先后顺序不变的情况下，将数组里面所有的0移动到最后。 非0元素移动到前面。","text":"题解给定一个数组，数组中包含着若干个0，要求在保证非0元素在vector中先后顺序不变的情况下，将数组里面所有的0移动到最后。 非0元素移动到前面。 约束： 要求在一个vector内操作，不能新建数组。并要求尽可能少的操作步骤。 题解开始想的是从数组最后开始遍历，把0通过冒泡的方式逐一冒泡到数组的最后。这种方法很暴力。 一种比较高效的方法是模拟队列。 依次遍历数组，把元素0计数。如果当前队列nums.front()为0，则cnt++。 如果不为0，就把当前元素nums.front() push_back队列尾。 执行完把首元素从队列删掉 nums.erase(nums.begin()) 注意： erase()方法内的参数为当前元素的地址而不是值！ 代码（C++）1234567891011121314151617181920class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int cnt = 0; int len = nums.size(); for(int i = 0; i &lt; len; i++) &#123; if(!nums.front()) &#123; cnt++; nums.erase(nums.begin()); &#125; else &#123; nums.push_back(nums.front()); nums.erase(nums.begin()); &#125; &#125; for(int i = 0; i &lt; cnt; i++) &#123; nums.push_back(0); &#125; &#125;&#125;;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.ariesjch.top/tags/leetcode/"}]},{"title":"414. Third Maximum Number 题解","slug":"414-Third-Maximum-Number-题解","date":"2017-11-12T06:37:31.000Z","updated":"2018-01-25T12:31:23.229Z","comments":true,"path":"2017/11/12/414-Third-Maximum-Number-题解/","link":"","permalink":"http://www.ariesjch.top/2017/11/12/414-Third-Maximum-Number-题解/","excerpt":"题意找到给定数组的第三个大的数， 如果不存在第三大的数则返回该数组最大的数。 要求在O(n)复杂度内解决此题","text":"题意找到给定数组的第三个大的数， 如果不存在第三大的数则返回该数组最大的数。 要求在O(n)复杂度内解决此题 题解使用最小堆Heap找到第三大的元素。 先将数组放入map中，用来统计每一个元素在数组中出现的次数，只需要把数组中不同的元素压入堆中。 pop() 两次，如果当前堆为空，说明不存在第三大的元素。如果不为空，当前堆顶元素即为第三大元素。 代码（C++）1234567891011121314151617181920class Solution &#123;public: int thirdMax(vector&lt;int&gt;&amp; nums) &#123; map&lt;int, int&gt; mp; priority_queue&lt;int&gt; heap; for(int i = 0; i &lt; nums.size(); i++) &#123; mp[nums[i]]++; if(mp[nums[i]] == 1) heap.push(nums[i]); &#125; int maxium = heap.top(); heap.pop(); heap.pop(); if(heap.empty()) return maxium; else return heap.top(); &#125;&#125;;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.ariesjch.top/tags/leetcode/"}]},{"title":"532. K-diff Pairs in an Array 题解","slug":"532-K-diff-Pairs-in-an-Array-题解","date":"2017-11-12T05:45:26.000Z","updated":"2018-01-25T12:31:23.345Z","comments":true,"path":"2017/11/12/532-K-diff-Pairs-in-an-Array-题解/","link":"","permalink":"http://www.ariesjch.top/2017/11/12/532-K-diff-Pairs-in-an-Array-题解/","excerpt":"题意一给定数组，问数组中有多少组数对(i, j) 保证i,j两个数的绝对差值为k。每组数对只计数一次。 如[1 3 4 5] , k=2 数对为(1, 3) (3, 5) , cnt=2","text":"题意一给定数组，问数组中有多少组数对(i, j) 保证i,j两个数的绝对差值为k。每组数对只计数一次。 如[1 3 4 5] , k=2 数对为(1, 3) (3, 5) , cnt=2 题解两个循环暴力求数对数会TLE。 使用 map O(lgn)。将数组元素存入map中，遍历一次数组，对每一个元素nums[i] + k 判断map中是否存在这个数。 特判当k=0的情况，如果判断map[nums[i]+k]&gt;0，[1 3 4 5] output=4,每个元素map值均大于0。所以当k=0时，使用map[nums[i]+k]&gt;1 来判断。 整体复杂度为O(nlgn) 代码（C++）1234567891011121314151617181920212223class Solution &#123;public: int findPairs(vector&lt;int&gt;&amp; nums, int k) &#123; int cnt = 0; if(k &lt; 0 || nums.size() == 0) return 0; map&lt;int, int&gt; mp, mp1; for(int i = 0; i &lt; nums.size(); i++) &#123; mp[nums[i]]++; mp1[nums[i]]++; &#125; for(int i = 0; i &lt; nums.size(); i++) &#123; if(k != 0 &amp;&amp; mp[nums[i] + k] &gt; 0 &amp;&amp; mp1[nums[i] + k] == mp[nums[i] + k]) &#123; cnt++; mp[nums[i] + k]--; &#125; else if(k == 0 &amp;&amp; mp[nums[i] + k] &gt; 1 &amp;&amp; mp1[nums[i] + k] == mp[nums[i] + k]) &#123; cnt++; mp[nums[i] + k]--; &#125; &#125; return cnt; &#125;&#125;;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.ariesjch.top/tags/leetcode/"}]},{"title":"python 逐行读取数据","slug":"python-逐行读取数据","date":"2017-11-10T12:31:14.000Z","updated":"2018-01-25T12:31:26.634Z","comments":true,"path":"2017/11/10/python-逐行读取数据/","link":"","permalink":"http://www.ariesjch.top/2017/11/10/python-逐行读取数据/","excerpt":"12345with open(filename,'r') as file: while True: line = file.readline() if not line: break","text":"12345with open(filename,'r') as file: while True: line = file.readline() if not line: break","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.ariesjch.top/tags/python/"}]},{"title":"语音录制并识别","slug":"语音录制并识别","date":"2017-11-10T10:47:56.000Z","updated":"2018-01-25T12:31:27.808Z","comments":true,"path":"2017/11/10/语音录制并识别/","link":"","permalink":"http://www.ariesjch.top/2017/11/10/语音录制并识别/","excerpt":"代码实现","text":"代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import wavefrom pyaudio import PyAudio,paInt16from aip import AipSpeechAPP_ID = 'your app_id'API_KEY = 'your api_key'SECRET_KEY = 'your secret_key'aipSpeech = AipSpeech(APP_ID,API_KEY,SECRET_KEY)framerate = 8000NUM_SAMPLES = 2000channels = 1sampwidth = 2TIME = 2def save_wave_file(filename,data): wf = wave.open(filename,'wb') wf.setnchannels(channels) wf.setsampwidth(sampwidth) wf.setframerate(framerate) wf.writeframes(b\"\".join(data)) wf.close()def record_wave(): pa = PyAudio() stream = pa.open(format = paInt16,channels = 1, rate = framerate, input = True, frames_per_buffer = NUM_SAMPLES) my_buff = [] count = 0 while count &lt; TIME*10: string_audio_data = stream.read(NUM_SAMPLES) my_buff.append(string_audio_data) count+=1 print('.') save_wave_file('01.wav',my_buff) stream.close()chunk = 2014def play(): wf = wave.open(r\"01.wav\",'rb') p = PyAudio() stream = p.open(format=p.get_format_from_width(wf.getsampwidth()),channels= wf.getnchannels(),rate=wf.getframerate(),output=True) while True: data = wf.readframes(chunk) if data == \"\": break stream.write(data) stream.close() p.terminate()def get_file_content(filepath): with open(filepath,'rb') as fp: return fp.read()def regorinize_voice(): return aipSpeech.asr(get_file_content('2.wav'),'pcm',16000, &#123; 'lan': 'zh', &#125;)if __name__ == '__main__': record_wave() print('over!!!') play() print(regorinize_voice())","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.ariesjch.top/tags/python/"}]},{"title":"566. Reshape the Matrix 题解","slug":"566-Reshape-the-Matrix-题解","date":"2017-11-10T07:02:51.000Z","updated":"2018-01-25T12:31:23.399Z","comments":true,"path":"2017/11/10/566-Reshape-the-Matrix-题解/","link":"","permalink":"http://www.ariesjch.top/2017/11/10/566-Reshape-the-Matrix-题解/","excerpt":"题意给定一二维数组，问能否用r*c维数组装下此数组。 保证此数组的数据遍历顺序不改变。","text":"题意给定一二维数组，问能否用r*c维数组装下此数组。 保证此数组的数据遍历顺序不改变。 题解r * c 为目标数组数据的个数， 当目标数组需要的数据个数和给定数组提供数据的个数相等时，对给定数组进行遍历，获得结果。 当两个数组的数据个数不相等时， 就返回原给定数组 vector nums 代码（C++）123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int r, int c) &#123; int need = r * c; int have = nums.size() * nums[0].size(); int k = 0, p = 0; int cnt = 0; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; temp; if(have != need) return nums; else &#123; for(int i = 0; i &lt; nums.size(); i++) &#123; for(int j = 0; j &lt; nums[0].size(); j++) &#123; temp.push_back(nums[i][j]); cnt++; if(cnt == c) &#123; ans.push_back(temp); temp.clear(); cnt = 0; &#125; p++; &#125; &#125; return ans; &#125; &#125;&#125;;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.ariesjch.top/tags/leetcode/"}]},{"title":"605. Can Place Flowers 题解","slug":"605-Can-Place-Flowers-题解","date":"2017-11-09T14:07:38.000Z","updated":"2018-01-25T12:31:23.453Z","comments":true,"path":"2017/11/09/605-Can-Place-Flowers-题解/","link":"","permalink":"http://www.ariesjch.top/2017/11/09/605-Can-Place-Flowers-题解/","excerpt":"题意一花坛，1 代表已经栽好花， 0 代表该位置还没有栽花。 给定一数字 n， 问能否在该花坛中栽 n 株花。 栽花需要符合 相邻位置不栽花 的原则。","text":"题意一花坛，1 代表已经栽好花， 0 代表该位置还没有栽花。 给定一数字 n， 问能否在该花坛中栽 n 株花。 栽花需要符合 相邻位置不栽花 的原则。 题解从 0 位置开始遍历， 直到最后一位。 在当前位置满足 前后两个位置和当前位置均为0的时候，该位置可栽花 flower[i] = 1，并且栽花数 cnt++。 要对 首位和最后一位进行特判： 首位为0， 第二位为0， 首位种花 flower[0] = 1, cnt++ 末位为0， 倒数第二位为0， 最后一位种花 flower[flower.size()-2] = 1, cnt++ 代码（C++）12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) &#123; if(n == 0) return true; int cnt = 0; for(int i = 0; i &lt; flowerbed.size(); i++) &#123; if(i == 0 &amp;&amp; flowerbed[i] == 0 &amp;&amp; flowerbed[i+1] == 0) &#123; flowerbed[i] = 1; cnt++; &#125; else if(i != 0 &amp;&amp; i != flowerbed.size()-1 &amp;&amp; flowerbed[i-1] == 0 &amp;&amp; flowerbed[i+1] == 0 &amp;&amp; flowerbed[i] == 0) &#123; flowerbed[i] = 1; cnt++; &#125; else if(i == flowerbed.size()-1 &amp;&amp; flowerbed[i-1] == 0 &amp;&amp; flowerbed[i] == 0) &#123; flowerbed[i] = 1; cnt++; &#125; &#125; if(cnt &gt;= n) return true; else return false; &#125;&#125;;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.ariesjch.top/tags/leetcode/"}]},{"title":"py -2 报错： Requested Python version (2) not installed ","slug":"py-2-报错：-Requested-Python-version-2-not-installed","date":"2017-11-09T09:05:50.000Z","updated":"2018-01-25T12:31:26.617Z","comments":true,"path":"2017/11/09/py-2-报错：-Requested-Python-version-2-not-installed/","link":"","permalink":"http://www.ariesjch.top/2017/11/09/py-2-报错：-Requested-Python-version-2-not-installed/","excerpt":"Windows 上 Python2 和 3 如何兼容？ 目前国内网站经常会让大家把其中一个python.exe改个名字。（之前我就是这样搞的，但是这个是错误做法！！！ 这样区分两个可执行文件的名字，但是这样做有一个重大的隐患，就是修改了名字的 python 对应的 pip 将无法使用。","text":"Windows 上 Python2 和 3 如何兼容？ 目前国内网站经常会让大家把其中一个python.exe改个名字。（之前我就是这样搞的，但是这个是错误做法！！！ 这样区分两个可执行文件的名字，但是这样做有一个重大的隐患，就是修改了名字的 python 对应的 pip 将无法使用。 官方的做法： 在安装 python3（&gt;= 3.3）的时候，python 的安装包在系统中安装了一个启动器 py.exe，默认放置在文件夹 C:\\Windows\\下面。 这个启动器允许我们指定使用 python2 还是 python3 来运行代码。 前提是已经成功安装了 python2 和 python3。 但是， 为什么我安装了 python2 和 python3， 使用 py -2 和 py -3 两个命令还是会报错。 Requested Python version (2) not installed。 我的错误原因是之前安装过 python，安装的位置不同，导致注册表内的信息是错误的。 解决方法： 打开注册表regedit， HKEY_LOCAL_MACHINE|HKEY_CURRENT_USER\\SOFTWARE\\xxx 这两个位置下面的python， 查看下python的路径，发现路径是错的。 将路径改成当前的 python 路径。 改完之后尝试执行 py -2 和 py -3 两个命令， 发现 py -3 可以正常执行了， 但是 py -2 还是无法执行，仍报刚刚的错误。 这种情况说明是先安装的 python2 后安装的 python3。 那就找到 python2 的安装包把 python2 重新安装下或者修复一下。 解决链接： https://stackoverflow.com/questions/27503003/py-launcher-does-not-find-my-python-2-7","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.ariesjch.top/tags/python/"}]},{"title":"661. Image Smoother 题解","slug":"661-Image-Smoother-题解","date":"2017-11-08T10:04:04.000Z","updated":"2018-01-25T12:31:23.495Z","comments":true,"path":"2017/11/08/661-Image-Smoother-题解/","link":"","permalink":"http://www.ariesjch.top/2017/11/08/661-Image-Smoother-题解/","excerpt":"题意二维数组每一个值为周围元素求和的平均值。 | 1 1 1 || 1 0 1 || 1 1 1 | output : | 0 0 0 || 0 0 0 || 0 0 0 |","text":"题意二维数组每一个值为周围元素求和的平均值。 | 1 1 1 || 1 0 1 || 1 1 1 | output : | 0 0 0 || 0 0 0 || 0 0 0 | 题解每个元素周围都有8个方向，算上自身为9个方向。 向9个方向搜索（通过 int dx[], int dy[]） 对每个元素都要在9个方向遍历下 dx,dy 。 对搜索目标元素的索引进行判断：（索引）nx = i + dx[k]ny = j + dy[k] bool judge() 函数 judge(nx,ny) 判断元素是否合法（在边界之内）。如果合法 cnt++ （累加出该元素是由周围几个元素所求 num+=M[nx][ny] res = num/cnt 即为该元素最后的值 代码（C++）123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: bool judge(int x, int y, int n, int m) &#123; if(x &lt; 0 || y &lt; 0 || x &gt;= n || y &gt;= m) return 0; return 1; &#125; vector&lt;vector&lt;int&gt;&gt; imageSmoother(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; int dx[] = &#123;-1, 0, 1, -1, 1, -1, 0, 1, 0&#125;; int dy[] = &#123;-1, -1, -1, 0, 0, 1, 1, 1, 0&#125;; int n = M.size(); int m = M[0].size(); vector&lt;vector&lt;int&gt;&gt; ans; for(int i = 0; i &lt; n; i++) &#123; vector&lt;int&gt; temp; for(int j = 0; j &lt; m; j++) &#123; int num = 0; int cnt = 0; for(int k = 0; k &lt; 9; k++) &#123; int nx = i + dx[k]; int ny = j + dy[k]; if(judge(nx, ny, n, m)) &#123; num += M[nx][ny]; cnt++; &#125; &#125; temp.push_back(num/cnt); &#125; ans.push_back(temp); &#125; return ans; &#125;&#125;;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.ariesjch.top/tags/leetcode/"}]},{"title":"665. Non-decreasing Array 题解","slug":"665-Non-decreasing-Array-题解","date":"2017-11-07T12:45:45.000Z","updated":"2018-01-25T12:31:23.518Z","comments":true,"path":"2017/11/07/665-Non-decreasing-Array-题解/","link":"","permalink":"http://www.ariesjch.top/2017/11/07/665-Non-decreasing-Array-题解/","excerpt":"","text":"代码（C++）1234567891011121314151617181920212223class Solution &#123;public: bool checkPossibility(vector&lt;int&gt;&amp; nums) &#123; int maxium = max(nums[0], nums[1]); int maxci = min(nums[0], nums[1]); int cnt = 0; for(int i = 1; i &lt; nums.size(); i++) &#123; if(nums[i] &gt; maxci &amp;&amp; nums[i] &lt; maxium) maxci = nums[i]; if(nums[i] &gt; maxium) &#123;maxci = maxium; maxium = nums[i];&#125; if(i &gt;= 2 &amp;&amp; maxci &gt; nums[i] &amp;&amp; i != nums.size()-1 &amp;&amp; nums[i-1] &gt; nums[i+1]) return false; if(nums[i] &lt; nums[i-1]) cnt++; if(cnt &gt; 1) return false; &#125; return true; &#125;&#125;;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.ariesjch.top/tags/leetcode/"}]},{"title":"674. Longest Continuous Increasing Subsequence 题解","slug":"674-Longest-Continuous-Increasing-Subsequence-题解","date":"2017-11-07T06:34:00.000Z","updated":"2018-01-25T12:31:23.563Z","comments":true,"path":"2017/11/07/674-Longest-Continuous-Increasing-Subsequence-题解/","link":"","permalink":"http://www.ariesjch.top/2017/11/07/674-Longest-Continuous-Increasing-Subsequence-题解/","excerpt":"题意求一给定数组的最大自增子序列的长度。 [1 3 5 4 7] 长度： 3","text":"题意求一给定数组的最大自增子序列的长度。 [1 3 5 4 7] 长度： 3 题解用一数组leng[]标记给定数组nums[]的每一位置为子序列自增结束点的序列长度。 初始化 leng[] 的每一位置的值为 1， 如果当前位置大于前一位置的值， 下一位置的 leng[i] = leng[i-1] + 1 并且在循环过程中 用一变量 maxium 来记录当前最大的子序列长度。 代码（C++）1234567891011121314151617181920class Solution &#123;public: int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 0) return 0; // 存储当前位置结束的最大子序列长度 int leng[10001]; for(int i = 0; i &lt; nums.size(); i++) leng[i] = 1; int maxium = 1; for(int i = 1; i &lt; nums.size(); i++) &#123; if(nums[i] &gt; nums[i-1]) leng[i] = leng[i-1] + 1; if(leng[i] &gt; maxium) maxium = leng[i]; &#125; return maxium; &#125;&#125;;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.ariesjch.top/tags/leetcode/"}]},{"title":"在图像右上角添加文字内容 pillow应用","slug":"在图像右上角添加文字内容-pillow应用","date":"2017-11-07T05:39:56.000Z","updated":"2018-01-25T12:31:27.508Z","comments":true,"path":"2017/11/07/在图像右上角添加文字内容-pillow应用/","link":"","permalink":"http://www.ariesjch.top/2017/11/07/在图像右上角添加文字内容-pillow应用/","excerpt":"在图像右上角添加文字内容。 示例图如下：","text":"在图像右上角添加文字内容。 示例图如下： 代码123456789101112131415161718from PIL import ImageDraw, ImageFont, ImageColor, Imagedef add_num(img): # 创建 draw 对象 draw = ImageDraw.Draw(img) # 创建字体 myfont = ImageFont.truetype('C:/windows/fonts/Arial.ttf', size=60) fillcolor = ImageColor.colormap.get('red') width, height = img.size draw.text((width-120,0), '99+', fill=fillcolor, font=myfont) img.save('result.jpg', 'jpeg') return 0if __name__ == '__main__': image = Image.open('touxiang.jpg') add_num(image)eight=\"1500px\"&gt;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.ariesjch.top/tags/python/"}]},{"title":"695. Max Area of Island 题解","slug":"695-Max-Area-of-Island-题解","date":"2017-11-06T05:15:32.000Z","updated":"2018-01-25T12:31:23.608Z","comments":true,"path":"2017/11/06/695-Max-Area-of-Island-题解/","link":"","permalink":"http://www.ariesjch.top/2017/11/06/695-Max-Area-of-Island-题解/","excerpt":"题意给定一二维数组，1 代表陆地， 0 代表海。 每一个元素上下左右四个方向连通为一个连接陆地。求这个数组中最大的陆地面积。","text":"题意给定一二维数组，1 代表陆地， 0 代表海。 每一个元素上下左右四个方向连通为一个连接陆地。求这个数组中最大的陆地面积。 题解对二维数组的每一位元素进行深度优先搜索，看当前元素的上下左右是否为陆地。 如果为陆地，则沿陆地方向搜索到底，知道越界或当前遍历位置已经遍历过了为止。 对每一个位置的四个方向分别深搜，将每个方向的连通陆地相加，即为当前位置所处的最大连通面积。 代码（C++）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123;public: int vis[50][50]; int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; if(grid.size() == 0) &#123; return 0; &#125; memset(vis, 0, sizeof(vis)); int maxium = 0; // 遍历 1 for(int i = 0; i &lt; grid.size(); i++) &#123; for(int j = 0; j &lt; grid[i].size(); j++) &#123; if(grid[i][j] == 0) continue; int area = dfs_area(grid, i, j); if(area &gt; maxium) &#123; maxium = area; &#125; &#125; &#125; return maxium; &#125; int dfs_area(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y) &#123; if(grid[x][y] == 0 || vis[x][y] == 1) &#123; return 0; &#125; int area = 1; vis[x][y] = 1; if(x + 1 &lt; grid.size()) &#123; area += dfs_area(grid, x + 1, y); &#125; if(x - 1 &lt; grid.size()) &#123; area += dfs_area(grid, x - 1, y); &#125; if(y + 1 &lt; grid[0].size()) &#123; area += dfs_area(grid, x, y + 1); &#125; if(y - 1 &lt; grid[0].size()) &#123; area += dfs_area(grid, x, y - 1); &#125; return area; &#125;&#125;;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.ariesjch.top/tags/leetcode/"}]},{"title":"697. Degree of an Array 题解","slug":"697-Degree-of-an-Array-题解","date":"2017-11-05T12:48:23.000Z","updated":"2018-01-25T12:31:23.664Z","comments":true,"path":"2017/11/05/697-Degree-of-an-Array-题解/","link":"","permalink":"http://www.ariesjch.top/2017/11/05/697-Degree-of-an-Array-题解/","excerpt":"题意一个给定数组，求包含出现次数最多元素的最短子序列长度。","text":"题意一个给定数组，求包含出现次数最多元素的最短子序列长度。 题解要求这个最短子序列要包含出现次数最多的元素。就要找到这个出现次数最多的元素，然后在给定数组中找到第一次和最后一次出现的位置，然后两个位置下标做差加一即为最短子序列长度。 代码(C++)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution &#123;public: int findShortestSubArray(vector&lt;int&gt;&amp; nums) &#123; map&lt;int, int&gt; mmp; // 统计每个element出现的次数 for(int i = 0; i &lt; nums.size(); i++) &#123; mmp[nums[i]]++; &#125; map&lt;int, int&gt;::iterator p; int maxium = -1; // 找到出现次数最多element的次数 for(p = mmp.begin(); p != mmp.end(); p++) &#123; if(p-&gt;second &gt; maxium) maxium = p-&gt;second; &#125; vector&lt;int&gt; arr; // 寻找到出现次数最多的所有element for(p = mmp.begin(); p != mmp.end(); p++) &#123; if(p-&gt;second == maxium) arr.push_back(p-&gt;first); &#125; int result[50000], k = 0; for(int i = 0; i &lt; arr.size(); i++) &#123; int front, back; for(int j = 0; j &lt; nums.size(); j++) &#123; if(nums[j] == arr[i]) &#123; front = j; break; &#125; &#125; for(int j = nums.size()-1; j &gt;= 0; j--) &#123; if(nums[j] == arr[i]) &#123; back = j; break; &#125; &#125; result[k++] = back - front; // 求出每个element的子串长度 &#125; sort(result, result + k); return result[0] + 1; &#125;&#125;;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.ariesjch.top/tags/leetcode/"}]},{"title":"717. 1-bit and 2-bit Characters","slug":"717-1-bit-and-2-bit-Characters","date":"2017-11-05T04:15:41.000Z","updated":"2018-01-25T12:31:23.708Z","comments":true,"path":"2017/11/05/717-1-bit-and-2-bit-Characters/","link":"","permalink":"http://www.ariesjch.top/2017/11/05/717-1-bit-and-2-bit-Characters/","excerpt":"题意给一个数组，数组为01串组成。最后一位是否是一位","text":"题意给一个数组，数组为01串组成。最后一位是否是一位 题解先两位一判断，是否为11 或者 10， 循环至最后一位或者恰好能两两一组遍历完。 如果是剩一位，进行特判。0true,1false 如果恰好两两一组遍历完 false 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: bool isOneBitCharacter(vector&lt;int&gt;&amp; bits) &#123; int i = 0; while(i &lt; bits.size()) &#123; if(i&lt;bits.size()-1 &amp;&amp; bits[i] == 1) &#123; if(bits[i+1] == 1 || bits[i+1] == 0) &#123; i = i+2; if(i&gt;=bits.size()) &#123; return false; &#125; else if(i == bits.size()-1) &#123; if(bits[i] == 0) &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125; &#125; else if(i == bits.size()-1) &#123; if(bits[i] == 0) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; i++; &#125; &#125; &#125;&#125;;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.ariesjch.top/tags/leetcode/"}]},{"title":"OpenGL学习笔记（三）","slug":"OpenGL学习笔记（三）","date":"2017-11-04T13:12:17.000Z","updated":"2018-01-25T12:31:26.223Z","comments":true,"path":"2017/11/04/OpenGL学习笔记（三）/","link":"","permalink":"http://www.ariesjch.top/2017/11/04/OpenGL学习笔记（三）/","excerpt":"在学习此节之前，建议将这三个单词先记下来： 顶点数组对象：Vertex Array Object，VAO 顶点缓冲对象：Vertex Buffer Object，VBO 索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO","text":"在学习此节之前，建议将这三个单词先记下来： 顶点数组对象：Vertex Array Object，VAO 顶点缓冲对象：Vertex Buffer Object，VBO 索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO 在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。 3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。 图形渲染管线可以被划分为两个主要部分： 第一部分把你的3D坐标转换为2D坐标 第二部分是把2D坐标转变为实际的有颜色的像素。 2D坐标和像素也是不同的，2D坐标精确表示一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕/窗口分辨率的限制。 图形渲染管线包含很多部分，每个部分都将在转换顶点数据到最终像素这一过程中处理各自特定的阶段。我们会概括性地解释一下渲染管线的每个部分，让你对图形渲染管线的工作方式有个大概了解。 首先，我们以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)；顶点数据是一系列顶点的集合。一个顶点(Vertex)是一个3D坐标的数据的集合。而顶点数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据 为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。 图形渲染管线的第一个部分是顶点着色器(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。 图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；本节例子中是一个三角形。 图元装配阶段的输出会传递给几何着色器(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。 几何着色器的输出会被传入光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。 开始绘制图形之前，我们必须先给OpenGL输入一些顶点数据。OpenGL是一个3D图形库，所以我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）。OpenGL不是简单地把所有的3D坐标变换为屏幕上的2D像素；OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1.0到1.0的范围内时才处理它。所有在所谓的标准化设备坐标(Normalized Device Coordinates)范围内的坐标才会最终呈现在屏幕上（在这个范围以外的坐标都不会显示）。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://www.ariesjch.top/tags/OpenGL/"}]},{"title":"百度人脸识别api学习","slug":"百度人脸识别api学习","date":"2017-11-04T12:55:37.000Z","updated":"2018-01-25T12:31:27.687Z","comments":true,"path":"2017/11/04/百度人脸识别api学习/","link":"","permalink":"http://www.ariesjch.top/2017/11/04/百度人脸识别api学习/","excerpt":"百度AI平台人脸识别api学习 实践了人脸识别api，python实现。 api文档参看 百度AI平台官网","text":"百度AI平台人脸识别api学习 实践了人脸识别api，python实现。 api文档参看 百度AI平台官网 123456789101112131415161718192021222324252627282930313233343536373839404142from aip import AipFaceAPP_ID = 'your app_id'API_KEY = 'your api_key'SECRET_KEY = 'your secret_key'aipFace = AipFace(APP_ID, API_KEY, SECRET_KEY)def get_file_content(path): with open(path, 'rb') as fp: return fp.read()def face_detect(path): options = &#123; 'max_face_num': 10, 'face_fields': \"age, beauty, expression, faceshape\", &#125; result = aipFace.detect(path, options) return resultdef face_match(images): options = &#123; 'result': \"score\", &#125; result = aipFace.match(images, options) return resultif __name__ == '__main__': image1 = get_file_content('erren.jpg') # image2 = get_file_content('b.jpg') # images = [image1, image2] c1 = get_file_content('fa.jpg') c2 = get_file_content('c.jpg') lan = get_file_content('lanni.jpg') images = [c1, c2] # print face_match(images) print face_detect(lan)","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.ariesjch.top/tags/python/"}]},{"title":"OpenGL学习笔记（二）","slug":"OpenGL学习笔记（二）","date":"2017-11-04T02:29:07.000Z","updated":"2018-01-25T12:31:26.368Z","comments":true,"path":"2017/11/04/OpenGL学习笔记（二）/","link":"","permalink":"http://www.ariesjch.top/2017/11/04/OpenGL学习笔记（二）/","excerpt":"创建窗口首先创建一个OpenGL上下文(Context)和一个用于显示的窗口。 最流行的几个库有 GLUT，SDL，SFML，GLFW。","text":"创建窗口首先创建一个OpenGL上下文(Context)和一个用于显示的窗口。 最流行的几个库有 GLUT，SDL，SFML，GLFW。 GLFWGLFW 是一个专门针对OpenGL的C语言库，提供了一些渲染物体所需的最低限度的接口。允许用户创建OpenGL上下文，定义窗口参数以及处理用户输入。 123456789101112#include&lt;glad\\glad.h&gt;#include&lt;GLFW\\glfw3.h&gt;int main()&#123; glfwInit(); // 初始化 GLFW glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); // 配置 GLFW glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); return 0;&#125; glfwWindowHint 函数的第一个参数代表选项的名称，我们可以从很多以 GLFW_ 开头的枚举值中选择； 第二个参数接受一个整形， 用来设置这个选项的值。所有选项以及对应的值都可以在 http://www.glfw.org/docs/latest/window.html#window_hints 这篇文档中找到。 如果使用的是 Mac OS X 系统， 需要加入下面这行代码到配置中1glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); 创建一个窗口对象，这个窗口对象存放了所有和窗口相关的数据，而且会被GLFW的其他函数频繁地用到 123456789// 创建窗口对象 GLFWwindow* window = glfwCreateWindow(800, 600, \"Hello, OpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"创建窗口失败\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwCreateWindow 函数参数 1)宽 2)高 3)窗口名称 4)？？ 5)？？ 创建完窗口将通知 GLFW 将我们的窗口的上下文设置为当前线程的主上下文。 GLADGLAD 是用来管理OpenGL的函数指针的， 所以在调用任何OpenGL函数之前我们需要初始化 GLAD 123456// 初始化 GLAD if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"初始化GLAD失败\" &lt;&lt; std::endl; return -1; &#125; 给GLAD传入了用来加载系统相关的OpenGL函数指针地址的函数。 GLFW 给我们的是 glfwGetProcAddress，它根据我们编译的系统定义了正确的函数。 视口？？ 视口和创建窗口 区别 在开始渲染之前必须告诉 OpenGL 渲染窗口的尺寸大小， 即视口(Viewport)，这样OpenGL才只能知道怎样根据窗口大小显示数据和坐标。 可以调用 glViewport 函数 来设置窗口的维度(Dimension) 1glViewport(0, 0, 800, 600); 参数： 前两个参数控制窗口左下角的位置 3）渲染窗口的宽度 4）渲染窗口的高度 我们实际上也可以将视口的维度设置为比GLFW的维度小，这样子之后所有的OpenGL渲染将会在一个更小的窗口中显示，这样子的话我们也可以将一些其它元素显示在OpenGL视口之外。 OpenGL幕后使用glViewport中定义的位置和宽高进行2D坐标的转换，将OpenGL中的位置坐标转换为你的屏幕坐标。例如，OpenGL中的坐标(-0.5, 0.5)有可能（最终）被映射为屏幕中的坐标(200,450)。注意，处理过的OpenGL坐标范围只为-1到1，因此我们事实上将(-1到1)范围内的坐标映射到(0, 800)和(0, 600)。 当用户改变窗口大小的时候，视口也应该被调整。 我们可以对窗口注册一个回调函数(Callback Function), 它会在每次窗口大小被调整的时候被调用。回调函数原型为： 1void framebuffer_size_callback(GLFWwindow* window, int width, int height); 这个帧缓冲大小函数需要一个GLFWwindow作为它的第一个参数，以及两个整数表示窗口的新维度。每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理。 1234void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; glViewport(0, 0, width, height);&#125; 我们还需要注册这个函数，告诉 GLFW 我们希望每当窗口调整大小的时候调用这个函数： 1glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); 当窗口第一次显示的时候framebuffer_size_callback也会被调用。 准备好引擎希望程序在关闭前不断绘制图像并能接受用户输入。 在程序中添加一个 while 循环， 循环渲染(Render Loop)，它能在我们让GLFW退出前一直保持运行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;glad\\glad.h&gt;#include&lt;GLFW\\glfw3.h&gt;#include&lt;iostream&gt;// 函数声明void framebuffer_size_callback(GLFWwindow* window, int width, int height);void processInput(GLFWwindow *window);int main()&#123; glfwInit(); // 初始化 GLFW glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); // 配置 GLFW glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, TRUE);#endif // 创建窗口对象 GLFWwindow* window = glfwCreateWindow(800, 600, \"Hello, OpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"创建窗口失败\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); // 初始化 GLAD if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"初始化GLAD失败\" &lt;&lt; std::endl; return -1; &#125; // 循环渲染 while (!glfwWindowShouldClose(window)) // 检查 GLFW 是否要求退出 &#123; processInput(window); // render // ------ glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); glfwSwapBuffers(window); // 交换颜色缓冲，在迭代中被用来绘制，将会作为输出显示在屏幕上 glfwPollEvents(); // 检查触发事件、更新窗口状态，并调用对应的回调函数 &#125; glfwTerminate(); return 0;&#125;void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true);&#125;void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; glViewport(0, 0, width, height);&#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://www.ariesjch.top/tags/OpenGL/"}]},{"title":"OpenGL学习笔记（一）","slug":"OpenGL学习笔记（一）","date":"2017-11-04T02:17:07.000Z","updated":"2018-01-25T12:31:26.145Z","comments":true,"path":"2017/11/04/OpenGL学习笔记（一）/","link":"","permalink":"http://www.ariesjch.top/2017/11/04/OpenGL学习笔记（一）/","excerpt":"核心模式与立即渲染模式早期OpenGL使用立即渲染模式(Immediate mode , 固定渲染管线)， 这个模式绘图很方便。OpenGL大多数库被隐藏起来，开发者不能控制OpenGL如何计算自由。 从OpenGL 3.2开始，规范文档开始废弃立即渲染模式，鼓励开发者使用OpenGL 核心模式（Core-profile）","text":"核心模式与立即渲染模式早期OpenGL使用立即渲染模式(Immediate mode , 固定渲染管线)， 这个模式绘图很方便。OpenGL大多数库被隐藏起来，开发者不能控制OpenGL如何计算自由。 从OpenGL 3.2开始，规范文档开始废弃立即渲染模式，鼓励开发者使用OpenGL 核心模式（Core-profile） 状态机OpenGL 自身是巨大的状态机(State Machine): 一系列的变量描述OpenGL此刻应当如何运行。 OpenGL 的状态通常被称为 OpenGL上下文(Context)。通常使用如下途径改变OpenGL状态： 设置选项 操作缓冲最后使用当前OpenGL上下文进行渲染 当使用OpenGL的时候，状态设置函数(State-changing Function)，这类函数将会改变上下文。状态使用函数(State-using Function)，这类函数将会根据当前OpenGL的状态执行一些操作。 对象对象是指一些选项的集合，代表OpenGL状态的一个子集。 比如可以用一个对象来代表绘图窗口的设置， 就可以设置它的大小、支持的颜色位数等等。 可以看成 （Struct）","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://www.ariesjch.top/tags/OpenGL/"}]},{"title":"appium-doctor 不是内部或外部命令","slug":"appium-doctor-不是内部或外部命令","date":"2017-11-02T15:50:47.000Z","updated":"2018-01-25T12:31:23.784Z","comments":true,"path":"2017/11/02/appium-doctor-不是内部或外部命令/","link":"","permalink":"http://www.ariesjch.top/2017/11/02/appium-doctor-不是内部或外部命令/","excerpt":"单独配置 Android_Home 系统变量开始配置安卓环境的时候，没有新建 Android_Home 系统变量，而是直接将 D:\\SDK\\tools和 D:\\SDK\\platform-tools配置到了 Path 里。这样就会导致 appium-doctor 运行时失败。","text":"单独配置 Android_Home 系统变量开始配置安卓环境的时候，没有新建 Android_Home 系统变量，而是直接将 D:\\SDK\\tools和 D:\\SDK\\platform-tools配置到了 Path 里。这样就会导致 appium-doctor 运行时失败。 解决方法在设置系统环境变量的地方新建 Android_Home ( 注意是 系统变量 变量值： D:\\SDK (就是SDK的目录 在 Path 中加入 %ANDROID_HOME%\\tools;%ANDROID_HOME%\\platform-tools; ，在 tools 目录下执行 android 命令，并且在 platform-tools 目录下执行 adb 命令。 创建系统变量 Appium_Home 变量值：D:\\Appium ( 也就是Appium的目录 在 Path 中加入 %Appium_Home% 进入 D:\\Appium\\node_modules.bin ，运行 appium-doctor 即可成功。 第3步如果还不行，就将 Appium 文件夹下的 Appium\\node_modules.bin 加到系统环境变量 Path 中。 运行结果如图所示：","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://www.ariesjch.top/tags/软件测试/"}]},{"title":"如何连接外远程桌面","slug":"如何连接外远程桌面","date":"2017-11-01T11:32:27.000Z","updated":"2018-01-25T12:31:27.589Z","comments":true,"path":"2017/11/01/如何连接外远程桌面/","link":"","permalink":"http://www.ariesjch.top/2017/11/01/如何连接外远程桌面/","excerpt":"本机连接其他电脑的远程桌面Win + R -&gt; mstsc 输入 IP，点击 选项， 输入用户名和密码登录即可。","text":"本机连接其他电脑的远程桌面Win + R -&gt; mstsc 输入 IP，点击 选项， 输入用户名和密码登录即可。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"computer application","slug":"computer-application","permalink":"http://www.ariesjch.top/tags/computer-application/"}]},{"title":"opencv 灰度图转伪彩色图","slug":"opencv-灰度图转伪彩色图","date":"2017-10-29T08:18:59.000Z","updated":"2018-01-25T12:31:26.049Z","comments":true,"path":"2017/10/29/opencv-灰度图转伪彩色图/","link":"","permalink":"http://www.ariesjch.top/2017/10/29/opencv-灰度图转伪彩色图/","excerpt":"","text":"1234567891011121314151617181920212223242526272829#include &lt;opencv2/opencv.hpp&gt;#include &lt;stdio.h&gt;using namespace cv;int main(int argc, char* argv[])&#123; Mat img = imread(\"1.jpg\", CV_LOAD_IMAGE_GRAYSCALE);//采用灰度格式读取图片 namedWindow(\"bmp_img\"); imshow(\"bmp_img\", img); Mat img_pseudocolor(img.rows, img.cols, CV_8UC3);//构造RGB图像，参数CV_8UC3教程文档里面有讲解 int tmp = 0; for (int y = 0; y&lt;img.rows; y++)//转为伪彩色图像的具体算法 &#123; for (int x = 0; x&lt;img.cols; x++) &#123; tmp = img.at&lt;unsigned char&gt;(y, x); img_pseudocolor.at&lt;Vec3b&gt;(y, x)[0] = abs(255 - tmp); //blue img_pseudocolor.at&lt;Vec3b&gt;(y, x)[1] = abs(127 - tmp); //green img_pseudocolor.at&lt;Vec3b&gt;(y, x)[2] = abs(0 - tmp); //red &#125; &#125; namedWindow(\"img_pseudocolor\"); imshow(\"img_pseudocolor\", img_pseudocolor); waitKey(0); destroyAllWindows(); return 0;&#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"计算机视觉","slug":"计算机视觉","permalink":"http://www.ariesjch.top/tags/计算机视觉/"}]},{"title":"霍夫曼编码","slug":"霍夫曼编码","date":"2017-10-29T07:49:11.000Z","updated":"2018-01-25T12:31:28.230Z","comments":true,"path":"2017/10/29/霍夫曼编码/","link":"","permalink":"http://www.ariesjch.top/2017/10/29/霍夫曼编码/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;//Huffman树的节点类typedef struct Node&#123; char value; //结点的字符值 int weight; //结点字符出现的频度 Node *lchild,*rchild; //结点的左右孩子&#125;Node;//自定义排序规则，即以vector中node结点weight值升序排序bool ComNode(Node *p,Node *q)&#123; return p-&gt;weight&lt;q-&gt;weight;&#125;//构造Huffman树，返回根结点指针Node* BuildHuffmanTree(vector&lt;Node*&gt; vctNode)&#123; while(vctNode.size()&gt;1) //vctNode森林中树个数大于1时循环进行合并 &#123; sort(vctNode.begin(),vctNode.end(),ComNode); //依频度高低对森林中的树进行升序排序 Node *first=vctNode[0]; //取排完序后vctNode森林中频度最小的树根 Node *second=vctNode[1]; //取排完序后vctNode森林中频度第二小的树根 Node *merge=new Node; //合并上面两个树 merge-&gt;weight=first-&gt;weight+second-&gt;weight; merge-&gt;lchild=first; merge-&gt;rchild=second; vector&lt;Node*&gt;::iterator iter; iter=vctNode.erase(vctNode.begin(),vctNode.begin()+2); //从vctNode森林中删除上诉频度最小的两个节点first和second vctNode.push_back(merge); //向vctNode森林中添加合并后的merge树 &#125; return vctNode[0]; //返回构造好的根节点&#125;//用回溯法来打印编码void PrintHuffman(Node *node,vector&lt;int&gt; vctchar)&#123; if(node-&gt;lchild==NULL &amp;&amp; node-&gt;rchild==NULL) &#123;//若走到叶子节点，则迭代打印vctchar中存的编码 cout&lt;&lt;node-&gt;value&lt;&lt;\": \"; for(vector&lt;int&gt;::iterator iter=vctchar.begin();iter!=vctchar.end();iter++) cout&lt;&lt;*iter; cout&lt;&lt;endl; return; &#125; else &#123; vctchar.push_back(1); //遇到左子树时给vctchar中加一个1 PrintHuffman(node-&gt;lchild,vctchar); vctchar.pop_back(); //回溯，删除刚刚加进去的1 vctchar.push_back(0); //遇到左子树时给vctchar中加一个0 PrintHuffman(node-&gt;rchild,vctchar); vctchar.pop_back(); //回溯，删除刚刚加进去的0 &#125;&#125;int main()&#123; cout&lt;&lt;\"请输入要编码的字符,并以空格隔开（个数任意）：\"&lt;&lt;endl; vector&lt;Node*&gt; vctNode; //存放Node结点的vector容器vctNode char ch; //临时存放控制台输入的字符 while((ch=getchar())!='\\n') &#123; if(ch==' ')continue; //遇到空格时跳过，即没输入一个字符空一格空格 Node *temp=new Node; temp-&gt;value=ch; temp-&gt;lchild=temp-&gt;rchild = NULL; vctNode.push_back(temp); //将新的节点插入到容器vctNode中 &#125; cout&lt;&lt;endl&lt;&lt;\"请输入每个字符对应的频度，并以空格隔开：\"&lt;&lt;endl; for(int i=0;i&lt;vctNode.size();i++) cin&gt;&gt;vctNode[i]-&gt;weight; Node *root = BuildHuffmanTree(vctNode); //构造Huffman树，将返回的树根赋给root vector&lt;int&gt; vctchar; cout&lt;&lt;endl&lt;&lt;\"对应的Huffman编码如下：\"&lt;&lt;endl; PrintHuffman(root,vctchar); system(\"pause\");&#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.ariesjch.top/tags/数据结构/"}]},{"title":"opencv 环境配置","slug":"opencv-环境配置","date":"2017-10-23T11:59:50.000Z","updated":"2018-01-25T12:31:26.102Z","comments":true,"path":"2017/10/23/opencv-环境配置/","link":"","permalink":"http://www.ariesjch.top/2017/10/23/opencv-环境配置/","excerpt":"工具 vs2017 opencv 3.3 配置过程 进入 opencv 官网 https://opencv.org/releases.html， 点击 Win pack 下载。","text":"工具 vs2017 opencv 3.3 配置过程 进入 opencv 官网 https://opencv.org/releases.html， 点击 Win pack 下载。 将下载好的压缩包放到你想要放置的磁盘中(最后建一个新的文件夹 如 D:\\opencv， 解压缩选择此文件路径 然后配置环境变量 在 Path 中将 bin 文件夹路径配置进去。 打开 vs2017, 右击 项目 -&gt; 属性, 我配置的是 x64 位， 将平台均改为 x64 位。( 不然会出现 LNK1112 错误。。坑 在上面一步属性的页面 VC++目录 的 包含目录 中， 配置好 D:\\opencv\\opencv\\build\\include 和 D:\\opencv\\opencv\\build\\include\\opencv和 D:\\opencv\\opencv\\build\\include\\opencv2 库目录 中添加 lib 文件夹路径 D:\\opencv\\opencv\\build\\x64\\vc14\\lib 进入 链接器 -&gt; 输入， 在 附加依赖项 中将 lib 文件夹下的 .lib 文件添加进去（这里只需要写名字即可，不需要写路径 按照以上步骤就陪完 opencv 环境， 如果出现 LNK 1112 错误见下面方法先把属性页里面所有能看到需要选择平台和运行环境的都选择为 x64(以64位举例)有一个巨坑的地方！！！ 在属性页上方有 配置、 平台、 配置管理器 三个内容。 将平台选择为x64后进入配置管理器，发现里面的活动解决方案平台仍为x86，改为x64就可以了。。。 仍不行的话，自行百度吧。。。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"计算机视觉","slug":"计算机视觉","permalink":"http://www.ariesjch.top/tags/计算机视觉/"}]},{"title":"asp.net mvc5 根据输入框Key友好提示 Error","slug":"asp-net-mvc5-根据输入框Key友好提示-Error","date":"2017-10-19T07:27:54.000Z","updated":"2018-01-25T12:31:24.543Z","comments":true,"path":"2017/10/19/asp-net-mvc5-根据输入框Key友好提示-Error/","link":"","permalink":"http://www.ariesjch.top/2017/10/19/asp-net-mvc5-根据输入框Key友好提示-Error/","excerpt":"","text":"输入框输入不符合要求，在输入框下面友好的提示用户错误方法 1234567函数说明void ModelStateDictionary.AddModelError(string key, string errorMessage) //+1 重载// 比如密码不对ModelState.AddModelError(\"Password\", \"Your password is error!\");","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"asp.net mvc","slug":"asp-net-mvc","permalink":"http://www.ariesjch.top/tags/asp-net-mvc/"}]},{"title":"vs 创建控制器 报错","slug":"vs-创建控制器-报错","date":"2017-10-19T06:52:12.000Z","updated":"2018-01-25T12:31:27.057Z","comments":true,"path":"2017/10/19/vs-创建控制器-报错/","link":"","permalink":"http://www.ariesjch.top/2017/10/19/vs-创建控制器-报错/","excerpt":"目前只有两种情况： 定义Model的时候没有添加 ID 创建完 Model 后没有 重新生成解决方案","text":"目前只有两种情况： 定义Model的时候没有添加 ID 创建完 Model 后没有 重新生成解决方案","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"asp.net mvc","slug":"asp-net-mvc","permalink":"http://www.ariesjch.top/tags/asp-net-mvc/"}]},{"title":"js 取消回车提交响应","slug":"js-取消回车提交响应","date":"2017-10-18T11:53:58.000Z","updated":"2018-01-25T12:31:25.921Z","comments":true,"path":"2017/10/18/js-取消回车提交响应/","link":"","permalink":"http://www.ariesjch.top/2017/10/18/js-取消回车提交响应/","excerpt":"使用 扫码枪 录入信息时，因为扫码枪自带回车，所以每次录入之后总是自动提交表单。 想法就是 取消回车提交响应","text":"使用 扫码枪 录入信息时，因为扫码枪自带回车，所以每次录入之后总是自动提交表单。 想法就是 取消回车提交响应 12&lt;div class=\"form-group\" onkeydown=\" if (event.keyCode == 13) &#123; return false;&#125;\"&gt; 在 存在录入多回车的输入框内的 中添加上面的js event.keyCode 不同的值都是什么？？？？","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.ariesjch.top/tags/javascript/"}]},{"title":"Datetime2 转换 datetime 类型出错","slug":"Datetime2-转换-datetime-类型出错","date":"2017-10-18T04:34:24.000Z","updated":"2018-01-25T12:31:25.092Z","comments":true,"path":"2017/10/18/Datetime2-转换-datetime-类型出错/","link":"","permalink":"http://www.ariesjch.top/2017/10/18/Datetime2-转换-datetime-类型出错/","excerpt":"在 vs 中代码 给一个 Datetime 类型赋值，在执行存入数据库操作时，抛出异常 Datetime2 类型向 Datetime 类型转换出错","text":"在 vs 中代码 给一个 Datetime 类型赋值，在执行存入数据库操作时，抛出异常 Datetime2 类型向 Datetime 类型转换出错 vs中datetime默认是datetime类型，datetime2类型较datetime类型精度更高 解决方法 目前的方法是手动将 sql server 里 datetime 类型字段更改为 datetime2 类型。 待续。。。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://www.ariesjch.top/tags/SQL/"}]},{"title":"Datetime 相减返回天数","slug":"Datetime-相减返回天数","date":"2017-10-18T03:54:35.000Z","updated":"2018-01-25T12:31:25.063Z","comments":true,"path":"2017/10/18/Datetime-相减返回天数/","link":"","permalink":"http://www.ariesjch.top/2017/10/18/Datetime-相减返回天数/","excerpt":"根据两个 Datetime 类型的日期，求的两个日期间隔的天数。","text":"根据两个 Datetime 类型的日期，求的两个日期间隔的天数。 12345// 已知获得了两个日期 dt1, dt2var tmp = dt1 - dt2; // System.TimeSpan 类型var days = tmp.Days; // Days 为间隔的天数","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"asp.net mvc","slug":"asp-net-mvc","permalink":"http://www.ariesjch.top/tags/asp-net-mvc/"}]},{"title":"豆瓣api 调用","slug":"豆瓣api-调用","date":"2017-10-17T14:07:53.000Z","updated":"2018-01-25T12:31:28.070Z","comments":true,"path":"2017/10/17/豆瓣api-调用/","link":"","permalink":"http://www.ariesjch.top/2017/10/17/豆瓣api-调用/","excerpt":"项目应用github地址： https://github.com/ariescc/LibrarySystemProject 豆瓣开发者https://developers.douban.com/wiki/?title=book_v2","text":"项目应用github地址： https://github.com/ariescc/LibrarySystemProject 豆瓣开发者https://developers.douban.com/wiki/?title=book_v2 使用方法 BooksController.cs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// POST: Books/Create // 为了防止“过多发布”攻击，请启用要绑定到的特定属性，有关 // 详细信息，请参阅 https://go.microsoft.com/fwlink/?LinkId=317598。 [HttpPost] [ValidateAntiForgeryToken] [Auth(Code = \"libraryadmin\")] public ActionResult Create([Bind(Include = \"ID,Isbn,Title,Publisher,Image,Isbn10,Isbn13,Summary,Pages,Price,msg,code,Location,IsAvaliable\")] Book book) &#123; if (ModelState.IsValid) &#123; string isbn = book.Isbn; Book bookInfo; string json; // 获取豆瓣api信息 GetInfo(isbn, out bookInfo, out json); if (bookInfo != null) &#123; if (bookInfo.msg != null) &#123; //throw new Exception(\"获取失败\" + bookInfo.msg); ModelState.AddModelError(\"Isbn\", \"No data are gotten from Douban!\"); &#125; if (bookInfo.Title != null) &#123; book.Title = bookInfo.Title; &#125; if (bookInfo.Author != null) &#123; book.Author = bookInfo.Author; &#125; if (bookInfo.Publisher != null) &#123; book.Publisher = bookInfo.Publisher; &#125; if (bookInfo.Isbn10!=null)&#123; book.Isbn10 = bookInfo.Isbn10; &#125; if (bookInfo.Image != null) &#123; book.Image = bookInfo.Image; &#125; if (bookInfo.Isbn13 != null) &#123; book.Isbn13 = bookInfo.Isbn13; &#125; if (bookInfo.Summary != null) &#123; book.Summary = bookInfo.Summary; &#125; if (bookInfo.Pages != null) &#123; book.Pages = bookInfo.Pages; &#125; if (bookInfo.Price != null) &#123; book.Price = bookInfo.Price; &#125; string jsonOutput = json; unitOfWork.BookRepository.Insert(book); unitOfWork.Save(); return RedirectToAction(\"BooksManage\"); &#125; else &#123; //throw new Exception(\"获取失败\"); ModelState.AddModelError(\"Isbn\", \"No data can be gotten, please Manual input！\"); if(book.Title != null) &#123; book.Isbn13 = book.Isbn; unitOfWork.BookRepository.Insert(book); unitOfWork.Save(); return RedirectToAction(\"BooksManage\"); &#125; &#125; &#125; return View(book); &#125; 我是在图书管理系统添加一本新的图书时调用的这个接口，通过图书的Isbn 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 调用 豆瓣图书 api // 根据 ISBN 从豆瓣api获取图书的详细信息 //根据ISBN码从豆瓣API获取书籍详细信息 public static bool GetInfo(string isbn, out Book bookInfo, out string json) &#123; try &#123; //豆瓣API string uri = \"https://api.douban.com/v2/book/isbn/\" + isbn; //获取书籍详细信息，Json格式 json = DoGet(uri, \"utf-8\"); //将获取到的Json格式的文件转换为定义的类 bookInfo = ToMap(json); return true; &#125; catch &#123; //信息获取失败 bookInfo = null; json = \"\"; return false; &#125; &#125; // Json 实例化为 book 实体 //Json解析 private static Book ToMap(string jsonString) &#123; //实例化JavaScriptSerializer类的新实例 JavaScriptSerializer jss = new JavaScriptSerializer(); try &#123; //将指定的 JSON 字符串转换为 Dictionary&lt;string, object&gt; 类型的对象 return jss.Deserialize&lt;Book&gt;(jsonString); &#125; catch &#123; return null; &#125; &#125; //HTTP的GET请求，获取书籍详细信息 private static string DoGet(string url, string charset) &#123; HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url); request.Method = \"GET\"; request.ContentType = \"text/html;charset=UTF-8\"; HttpWebResponse response = (HttpWebResponse)request.GetResponse(); if (response != null) &#123; Stream myResponseStream = response.GetResponseStream(); StreamReader myStreamReader = new StreamReader(myResponseStream, System.Text.Encoding.GetEncoding(charset)); string retString = myStreamReader.ReadToEnd(); myStreamReader.Close(); myResponseStream.Close(); return retString; &#125; throw new Exception(); &#125; // Http 获取图书封面 //HTTP获取图片，获取书籍封面 public static Image DoGetImage(string url) &#123; WebRequest request = WebRequest.Create(url); WebResponse response = request.GetResponse(); if (response != null) &#123; Stream stream = response.GetResponseStream(); return Image.FromStream(stream); &#125; return DrawCover(); &#125; // 绘制封面 private static Bitmap DrawCover() &#123; Bitmap image = new Bitmap(102, 145); Graphics g = Graphics.FromImage(image); g.Clear(Color.Silver); StringFormat format = new StringFormat &#123; Alignment = StringAlignment.Center &#125;; g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias; //封面显示内容：暂无封面 g.DrawString(\"No Drawing\", new Font(\"黑体\", 12f, FontStyle.Regular), Brushes.Black, 51, 50, format); return image; &#125; 以上为后端代码 Create.cshtml 1234567&lt;div class=\"form-group\"&gt; @Html.LabelFor(model=&gt;model.Isbn, htmlAttributes: new &#123; @class = \"control-label col-md-2\"&#125;) &lt;div class=\"col-md-10\"&gt; @Html.EditorFor(model=&gt;model.Isbn, new &#123; htmlattributes = new &#123; @class=\"form-control\"&#125;&#125;) @Html.ValidationMessageFor(model=&gt;model.Isbn, \"\", new &#123; @class=\"text-danger\"&#125;) &lt;/div&gt;&lt;/div&gt; 以上为前端代码，只需要向后端提交一个表单，传入要搜索的Isbn即可。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"asp.net mvc","slug":"asp-net-mvc","permalink":"http://www.ariesjch.top/tags/asp-net-mvc/"}]},{"title":"ISBN 介绍","slug":"ISBN-介绍","date":"2017-10-17T12:37:06.000Z","updated":"2018-01-25T12:31:25.590Z","comments":true,"path":"2017/10/17/ISBN-介绍/","link":"","permalink":"http://www.ariesjch.top/2017/10/17/ISBN-介绍/","excerpt":"ISBN扩升至13位 现有ISBN的结构国际标准书号ISBN是英文International Standard Book Number的缩写，1971年国际标准化组织ISO（International Organization for Standardization）批准了国际标准书号在世界范围内实施，迄今已经有30多年的历史，参加国家有159个。国际标准书号由十位数字组成。由三条短横线分为四段，每一段都有不同的含义。","text":"ISBN扩升至13位 现有ISBN的结构国际标准书号ISBN是英文International Standard Book Number的缩写，1971年国际标准化组织ISO（International Organization for Standardization）批准了国际标准书号在世界范围内实施，迄今已经有30多年的历史，参加国家有159个。国际标准书号由十位数字组成。由三条短横线分为四段，每一段都有不同的含义。 第一段号码段是地区号，又叫组号(Group Identifier)，由设在德国柏林国立普鲁士文化遗产图书馆(Staatsbibliothek zu Berlin – Preu?ischerKulturbesitz)的国际标准书号中心(International ISBN Agency，简称IIA)分配。最短的是一位数字，最长的达五位数字，大体上兼顾文种、国别和地区。把全世界自愿申请参加国际标准书号体系的国家和地区，划分成若干组，各有固定的编码，如0、1代表英语出版物，7代表中国出版物等。第二段号码是出版社代码(Publisher Identifier)，由其隶属的国家或地区ISBN中心分配，允许取值范围为2-5位数字。出版社的规模越大，出书越多，其号码就越短。第三段是书序号(Title Identifier)，由出版社自己给出，每个出版社的书序号是定长的。最短的一位，最长的六位。出版社的规模越大，出书越多，序号越长。第四段是校验位（Check Digit），用10至2这9个数分别去乘标准书号的前9位数然后以11为模计算得到。取值范围为0-10，10由X代替。10位 ISBN： 0-393-04002-?位置 Total 1 2 3 4 5 6 7 8 9 10ISBN 0 3 9 3 0 4 0 0 2权重 10 9 8 7 6 5 4 3 2 –乘积 144 0 27 72 21 0 20 0 0 4 –校验位 = mod11 (11 – mod11 (Product Total)) = mod11 (11 –mod11 (144)) = 10 中国的ISBN1982年，中国参加ISBN系统，并成立中国ISBN中心（设在国家新闻出版署）。中国标准书号自1987年1月1日起实施，至1988年1月1日完全取代原用的统一书号。中国标准书号共分两部分, 第一部分为ISBN，是主体部分；第二部分为《中国图书馆图书分类法》基本大类类号和种次号。类号用《中图法》大类的字母。种次号是同一出版社出版同一学科门类图书的顺序号，由出版社自行编定。类号与种次号之间用中圆点(?)隔开。第一部分和第二部分分两行排列，也可用斜线隔开，排成一行。例如：《CALIS联机合作编目手册》的ISBN号为： 7-301-04815-7/G?626。 将升成13位的ISBN3.1 13位码的来源背景 目前国际公认用于商品包装的编码系统称为EAN－UCC系统，该系统由国际物品编码协会（EAN）与美国统一代码委员会（UCC）共同开发和维护，是全球统一和通用的商业标识系统，是对全球多行业供应链进行有效管理的一套开放性国际标准。EAN－UCC系统的编码有两种①UPC条形码，该条码主要在美国使用。②EAN-13条形码， EAN是European Article Number，是欧共体的“欧洲物品编码协会”吸取了UPC的经验而确立的物品表示符号。该协会于1997年更名为“国际物品编码协会”。使用EAN条形码的成员国除欧洲外，亚洲多国也使用此码，我国于1991年7月参加该协会。EAN－UCC系统致力于编码的全球唯一性，并解决编码混乱、重复和错误译码的问题， EAN成员组织和UCC通过特定的前缀协议确保代码在全世界的唯一性。国际物品编码协会（EAN International）指定给国际标准书号（ISBN）系统的专用前缀码是978。2004年，国际ISBN中心(IIA)出版了《13位国际标准书号指南》(Guidelines for the Implementation of 13-DigitISBNs)，描述了将于2007年启用的13位的ISBN的概况。国际标准化组织ISO将于2005年1月出版新的标准，该标准将以13位数字的Bookland EAN条形码，作为图书和图书相关产品的唯一条形码。到2007年1月1日起，全世界所有ISBN代理机构将只发布13位的ISBN。所以，出版社将有两年时间来完成10位ISBN到13位ISBN的升级。过渡期间内（2005-2007年），鼓励出版社根据国际ISBN中心(International ISBN Agency) 出版的《13位国际标准书号指南》为同一个文献提供10位和13位的ISBN号。 新的ISBN实际上就是现在的EAN（欧洲物品号）。现在出版的图书外封底（outside of back cover）的ISBN下面就有一个13位的号码，这就是EAN-13号，例如：CALIS联机合作编目手册的外封底的ISBN下面就有一个13位的号ISBN： 7-301-04815-7EAN-13： 978-7-301-04815-3前缀978（代表图书），中间一部分与ISBN相同，最后一位是校验码，校验位的加权算法与10位ISBN的算法不同。具体算法是：用1分别乘ISBN的前9位中的奇数位，用3乘以偶数位，成绩之和以10为模即可得到校验位的值，其值范围应该为0-9。Bookland EAN-13 = 978-0-393-04002-?位置 Total 1 2 3 4 5 6 7 8 9 10 11 12 13ISBN 9 7 8 0 3 9 3 0 4 0 0 2 ?权重 1 3 1 3 1 3 1 3 1 3 1 3 –乘积 81 9 21 8 0 3 27 3 0 4 0 0 6 –校验位= mod10 (10 – mod10 (Product Total)) = mod10 (10 –mod10 (81)) = 92007年1月1日以前，各国ISBN机构尚没有分配完的10位的ISBN可以在前面加前缀978，一旦现有的10位的ISBN号用完了，新申请的ISBN号码全部以979开始。即979前缀目前用于两种情况，一是新建出版社首次申请ISBN和已有出版社在2007年1月1日以后申请ISBN号，二是如果以978为前缀的号码先用完，那么就只能用979。13位的号码与10位的号码可以通过算法互相转换，转换方法见ISBN中心主页（http://www.isbn.org）的详细说明。3.2 对图书馆的影响ISBN的升级可使出版获得更多的号源，以适应海量增长的出版业的发展。但世界各地的出版商也将为升级现有的软件额外支付数百万美元。由于ISBN在书目检索和识别中的重要作用，图书馆界还是相当重视，美国国会图书馆已经对系统更新，从2004年10月1日开始已能够处理13位的ISBN号。此外，LC还作出了过渡时期（2004年10月1日—2007年1月1日)的策略：从2004年10月1日起，LC对同一文献的两个ISBN号（10位和13位）都要著录。著录顺序是13位的在前，10位的在后。例如：ISBN-13: 978-1-873671-00-0ISBN-10: 1-873671-008CALIS联合目录也在考虑更新相关的软件—查重和校验等，以能够顺利处理13位的ISBN号。各个图书馆的自动化系统也需做相应升级以适应13位的ISBN。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"ISBN","slug":"ISBN","permalink":"http://www.ariesjch.top/tags/ISBN/"}]},{"title":"PIL 生成缩略图","slug":"PIL-生成缩略图","date":"2017-10-16T12:40:11.000Z","updated":"2018-01-25T12:31:26.428Z","comments":true,"path":"2017/10/16/PIL-生成缩略图/","link":"","permalink":"http://www.ariesjch.top/2017/10/16/PIL-生成缩略图/","excerpt":"python 处理图片，生成图片缩略图。 使用Pillow库 12345from PIL import Imageim = Image.open('touxiang.jpg')print(im.format, im.size, im.mode)im.thumbnail((200, 100))im.save('thumb.jpg', 'JPEG')","text":"python 处理图片，生成图片缩略图。 使用Pillow库 12345from PIL import Imageim = Image.open('touxiang.jpg')print(im.format, im.size, im.mode)im.thumbnail((200, 100))im.save('thumb.jpg', 'JPEG') 生成缩略图thumbnail函数接受一个元组作为参数，分别对应着缩略图的宽高，在缩略时，函数会保持图片的宽高比例。如果输入的参数宽高和原图像宽高比不同，则会依据最小对应边进行原比例缩放。比如:一张图片为300420大小的图片当参数为（200,200）时，生成的缩略图大小为71100，保持原图的宽高比","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.ariesjch.top/tags/python/"}]},{"title":"yield study","slug":"yield-study","date":"2017-10-16T05:12:11.000Z","updated":"2018-01-25T12:31:27.137Z","comments":true,"path":"2017/10/16/yield-study/","link":"","permalink":"http://www.ariesjch.top/2017/10/16/yield-study/","excerpt":"廖雪峰网站python学习笔记generator 介绍 （通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。","text":"廖雪峰网站python学习笔记generator 介绍 （通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。 如果列表元素可以按照某种算法推算出来，可以在循环过程中不断推算出后续的元素。 这样就不必创建完整的list，从而节省大量的空间。 在 python 中一边循环一边计算的机制称为 生成器 generator 创建 generator 的方法 把列表生成式的 [] 改成 () 123456&gt;&gt;&gt; L = [x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt; 如果要打印list每一个元素， 可以通过 next(g) 获得 generator 的下一个返回值。 yieldgenerator 和函数的执行流程不一样，函数是顺序执行的，或者遇到return就返回。变成generator函数，每次调用next()的时候执行，遇到 yield 语句返回，再次执行时从上次返回的 yield 语句处继续执行。 例如：1234567def odd(): print('step1') yield 1 print('step2') yield(3) print('step3') yield(5) 把函数改成 generator 后， 我们基本不用 next() 来获取下一个返回值， 而是直接使用 for 循环来迭代。 12for n in fib(6): print(n) 但是用 for 循环调用 generator 时，发现拿不到 return 语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中 12345678g = fib(6)while True: try: x = next(g) print('g:', x) except StopIteration as s: print('Generator return value:', e.value) break","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.ariesjch.top/tags/python/"}]},{"title":"富文本编辑器插入图片显示 html 代码问题","slug":"富文本编辑器插入图片显示-html-代码问题","date":"2017-10-12T13:25:35.000Z","updated":"2018-01-25T12:31:27.627Z","comments":true,"path":"2017/10/12/富文本编辑器插入图片显示-html-代码问题/","link":"","permalink":"http://www.ariesjch.top/2017/10/12/富文本编辑器插入图片显示-html-代码问题/","excerpt":"问题描述在做图书管理系统的内容管理模块时，使用的是 ueditor 编辑器， 使用编辑器上传图片后，发现编辑发布好的文章里面的图片显示的是 html 代码。， 类似这样。","text":"问题描述在做图书管理系统的内容管理模块时，使用的是 ueditor 编辑器， 使用编辑器上传图片后，发现编辑发布好的文章里面的图片显示的是 html 代码。， 类似这样。 解决方案前端代码展示的问题。 富文本编辑器会把图片转码保存， 开始在前端展示文章的办法是1@Html.DisplayFor(model=&gt;model.Content) 这样展示的问题是所有的内容均以 html 编码输出展示。 修改为1@(new htmlString(model=&gt;model.Content)) 成功将 图片 显示出来~","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"asp.net mvc","slug":"asp-net-mvc","permalink":"http://www.ariesjch.top/tags/asp-net-mvc/"}]},{"title":"sql server 错误18456","slug":"sql-server-错误18456","date":"2017-10-11T05:37:15.000Z","updated":"2018-01-25T12:31:26.799Z","comments":true,"path":"2017/10/11/sql-server-错误18456/","link":"","permalink":"http://www.ariesjch.top/2017/10/11/sql-server-错误18456/","excerpt":"问题描述当以sa登录sql server 2012 报错 18456 解决方案 确定 登录的用户名和密码 是否正确。 确定 sa用户登录状态启用。 确定 服务器 允许sql server 和 Window 身份验证。 均成功后 在 sql server 配置服务器中确保动态端口号正确。 以上均不行，将所有的sql server 相关服务重启一遍。","text":"问题描述当以sa登录sql server 2012 报错 18456 解决方案 确定 登录的用户名和密码 是否正确。 确定 sa用户登录状态启用。 确定 服务器 允许sql server 和 Window 身份验证。 均成功后 在 sql server 配置服务器中确保动态端口号正确。 以上均不行，将所有的sql server 相关服务重启一遍。 相关链接https://jingyan.baidu.com/article/656db918faf80fe381249c1e.html 再不行，就继续搜索解决方案吧！&gt;_&lt;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://www.ariesjch.top/tags/SQL/"}]},{"title":"Palindrome Number","slug":"Palindrome-Number","date":"2017-10-10T14:00:59.000Z","updated":"2018-01-25T12:31:26.396Z","comments":true,"path":"2017/10/10/Palindrome-Number/","link":"","permalink":"http://www.ariesjch.top/2017/10/10/Palindrome-Number/","excerpt":"题目地址https://leetcode.com/problems/palindrome-number/ 题解判断 整数 是否为 回文数首先明确1.负数不是回文数","text":"题目地址https://leetcode.com/problems/palindrome-number/ 题解判断 整数 是否为 回文数首先明确1.负数不是回文数 2.0~9 均为回文数3.能整除10且不为0的数均不是回文数4.通过 Reverse Integer 将整数反转，和原数进行比较，如果相等则为回文数，否则不是。 1234567891011121314151617class Solution &#123;public: bool isPalindrome(int x) &#123; if(x&gt;=0&amp;&amp;x&lt;10) return true; else if(x&lt;0||x%10==0) return false; else &#123; int p=x; long long res = 0; while(x)&#123; res=res*10+x%10; x/=10; &#125; if(p==res)return true; else return false; &#125; &#125;&#125;;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.ariesjch.top/tags/leetcode/"}]},{"title":"Reverse Integer","slug":"Reverse-Integer","date":"2017-10-10T14:00:46.000Z","updated":"2018-01-25T12:31:26.659Z","comments":true,"path":"2017/10/10/Reverse-Integer/","link":"","permalink":"http://www.ariesjch.top/2017/10/10/Reverse-Integer/","excerpt":"题目地址https://leetcode.com/problems/reverse-integer/description/ 题解整数反转， 将123-》321， -123-》-321注意题中判断反转后的数是否超出 int 大小，通过 INT_MAX 和 INT_MIN 比较来判断是否越界。","text":"题目地址https://leetcode.com/problems/reverse-integer/description/ 题解整数反转， 将123-》321， -123-》-321注意题中判断反转后的数是否超出 int 大小，通过 INT_MAX 和 INT_MIN 比较来判断是否越界。 1234567891011class Solution &#123;public: int reverse(int x) &#123; long long res = 0; while(x) &#123; res = x%10 + res*10; x/=10; &#125; return (res&lt;INT_MIN||res&gt;INT_MAX)?0:res; &#125;&#125;;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.ariesjch.top/tags/leetcode/"}]},{"title":"Eclipse Customize Perspective 无反应","slug":"Eclipse-Customize-Perspective-无反应","date":"2017-10-06T12:37:27.000Z","updated":"2018-01-25T12:31:25.174Z","comments":true,"path":"2017/10/06/Eclipse-Customize-Perspective-无反应/","link":"","permalink":"http://www.ariesjch.top/2017/10/06/Eclipse-Customize-Perspective-无反应/","excerpt":"问题描述在解决工具栏无法显示 Eclemma 插件的问题，在另一篇文章中的解决方案是在 customize perspective 中勾选上 Eclemma。但是点击 Customize Perspective 没有响应。 在网上搜索到两个方案解决了此问题。","text":"问题描述在解决工具栏无法显示 Eclemma 插件的问题，在另一篇文章中的解决方案是在 customize perspective 中勾选上 Eclemma。但是点击 Customize Perspective 没有响应。 在网上搜索到两个方案解决了此问题。 解决方案方案一官网查了下，解释如下： 附上链接https://www.myeclipseide.com/PNphpBB2-viewtopic-t-30151.html，大概意思是按如下图所示步骤更新即可。读者可以试试官网给出的方法，如果可以打开Customize Perspective,就没有必要看下去了。 但是Lz人品不好，出现了下图情况。 没有可用更新。。。。。没办法了。。。在网上查了半天一无所获，就在Lz要放弃之时，在CSDN上找到了解决办法。链接：http://download.csdn.net/detail/miragepp/711238 解决方法如下：myeclipse 2014中customize persperctive设置无效，导致无法调整工具栏按钮，能联网的朋友可以通过自动更新解决，此工具提供给内网环境无法自动更新的朋友 1、将9个jar复制到myeclipse安装目录\\plugins中2、删除和这9个jar同包名但是版本号较低的9个文件3、重启myeclipse 2014 CSDN下载需要积分，链接 http://pan.baidu.com/s/1sjN3Lwh 方案二经过了方案一发现并没有解决问题，使用方案二。把 workplace 目录下的 .metadata 文件夹删掉（D:\\Workspace\\.metadata）。重启 Eclipse，重新定向此工作空间，解决~","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.ariesjch.top/tags/java/"}]},{"title":"Eclipse 工具栏无法加载出下载好的插件","slug":"Eclipse-工具栏无法加载出下载好的插件","date":"2017-10-06T12:34:54.000Z","updated":"2018-01-25T12:31:25.200Z","comments":true,"path":"2017/10/06/Eclipse-工具栏无法加载出下载好的插件/","link":"","permalink":"http://www.ariesjch.top/2017/10/06/Eclipse-工具栏无法加载出下载好的插件/","excerpt":"问题描述软件测试中有一个可以查看覆盖率的插件Eclemma，下载完之后在Eclipse的工具栏中发现并没有显示这个插件。","text":"问题描述软件测试中有一个可以查看覆盖率的插件Eclemma，下载完之后在Eclipse的工具栏中发现并没有显示这个插件。 解决方案Eclipse -&gt; window -&gt; Customize Perspective， 勾选上 Eclemma。","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.ariesjch.top/tags/java/"}]},{"title":"如何清理干净java环境","slug":"如何清理干净java环境","date":"2017-10-06T03:07:24.000Z","updated":"2018-01-25T12:31:27.566Z","comments":true,"path":"2017/10/06/如何清理干净java环境/","link":"","permalink":"http://www.ariesjch.top/2017/10/06/如何清理干净java环境/","excerpt":"介绍很多人在删除JDK时，往往会遇到大麻烦——即使将电脑中所有与JAVA有关 的文件删得一干二净（但通常情况下有些文件你是删不掉的，只有通过改名字的办法才能删掉，当然很多人也是这样做才将它们给删掉的），控制面板上仍然还显示 着JAVA的图标，这时候不论是卸载JDK还是你想安装新版的JDK，都会出现严重错误的警告。","text":"介绍很多人在删除JDK时，往往会遇到大麻烦——即使将电脑中所有与JAVA有关 的文件删得一干二净（但通常情况下有些文件你是删不掉的，只有通过改名字的办法才能删掉，当然很多人也是这样做才将它们给删掉的），控制面板上仍然还显示 着JAVA的图标，这时候不论是卸载JDK还是你想安装新版的JDK，都会出现严重错误的警告。 有人想试图用超级兔子 或者是优化大师之类的工具清除注册表中与JAVA有关的信息，也有人想自己手动删除它们（不得不说这样做很危险，你有可能使自己的电脑瘫痪），但结果是什 么？——还是出现错误警告，想安装新版的JDK安装不了，想删除旧版的JDK却删不干净，束手无策的人在绞尽脑汁之后，唯一能想到的办法就是重装系统。重 装系统？这个结果谁能接受？ 难道除了重装系统就没有别的办法了吗？ 办法当然有，既然问题出现在JAVA和操作系统这两个上面，那好，就在他们身上找答案？我们先找JAVA，看看SUN公司给我们的答复是什么？上SUN公司的官网，进入帮助中心，也就是这个网址：http://java.com/en/download/help/uninstall_java.xml 可以看到这里也有人遇到了同样的问题，看来这个问题出现的范围不小。下面是SUN公司给出的解决办法： If the normal uninstallation process (as mentioned above) fails, then please try Microsoft Windows Installer Cleanup Utility. This tool will ensure that all irrelevant Java Runtime Environment Microsoft Installer (msi) registries are removed. Detailed information and download is available at: Description of the Windows Installer CleanUp Utility 可以看到，它是让我们去Windows的官网去下载一个所谓的Windows安装清理工具，说这个工具可以将注册表中的信息一起清掉，既然SUN公司都这么说了，那我们只好照办了，下载这个工具之后，就使用它卸载掉JAVA，这个时候你就会发现自己的新JDK可以安装了 建议几点：（1）安装JDK的时候尽量将它装到C盘下，因为这里还有系统提供的一些与JAVA有关的文件（2）要卸载JDK，先用控制面板里的添加/删除程序这个工具，万一删不掉，就使用上面的工具去删。（3）卸载JDK前，先将环境变量中的CLASSPATH删掉，将PATH中与JAVA有关的部分也给去掉。 原文地址：http://java-cd.javaeye.com/blog/537557windows 清理工具地址：http://down.tech.sina.com.cn/page/16877.html","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.ariesjch.top/tags/java/"}]},{"title":"认识 CDN","slug":"认识-CDN","date":"2017-09-26T04:49:49.000Z","updated":"2018-01-25T12:31:27.771Z","comments":true,"path":"2017/09/26/认识-CDN/","link":"","permalink":"http://www.ariesjch.top/2017/09/26/认识-CDN/","excerpt":"初识 CDNCDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。","text":"初识 CDNCDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。 简介及原理CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。 服务模式内容分发网络(CDN)是一种新型网络构建方式，它是为能在传统的IP网发布宽带丰富媒体而特别优化的网络覆盖层；而从广义的角度，CDN代表了一种基于质量与秩序的网络服务模式。简单地说，内容分发网络(CDN)是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请求的重定向和内容管理4个要件，而内容管理和全局的网络流量管理(Traffic Management)是CDN的核心所在。通过用户就近性和服务器负载的判断，CDN确保内容以一种极为高效的方式为用户的请求提供服务。总的来说，内容服务基于缓存服务器，也称作代理缓存(Surrogate)，它位于网络的边缘，距用户仅有”一跳”(Single Hop)之遥。同时，代理缓存是内容提供商源服务器（通常位于CDN服务提供商的数据中心）的一个透明镜像。这样的架构使得CDN服务提供商能够代表他们客户，即内容供应商，向最终用户提供尽可能好的体验，而这些用户是不能容忍请求响应时间有任何延迟的。 关键技术（1）内容发布：它借助于建立索引、缓存、流分裂、组播（Multicast）等技术，将内容发布或投递到距离用户最近的远程服务点（POP）处；（2）内容路由：它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程POP上均衡用户的请求，以使用户请求得到最近内容源的响应；（3）内容交换：它根据内容的可用性、服务器的可用性以及用户的背景，在POP的缓存服务器上，利用应用层交换、流分裂、重定向（ICP、WCCP）等技术，智能地平衡负载流量；（4）性能管理：它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态。 主要特点1、本地Cache加速 提高了企业站点(尤其含有大量图片和静态页面站点)的访问速度，并大大提高以上性质站点的稳定性2、镜像服务 消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。3、远程加速 远程访问用户根据DNS负载均衡技术智能自动选择Cache服务器，选择最快的Cache服务器，加快远程访问的速度4、带宽优化 自动生成服务器的远程Mirror（镜像）cache服务器，远程用户访问时从cache服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点WEB服务器负载等功能。5、集群抗攻击 广泛分布的CDN节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种D.D.o.S攻击对网站的影响，同时保证较好的服务质量 。 摘自百度百科，用于收集及之后的深入学习","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"Net","slug":"Net","permalink":"http://www.ariesjch.top/tags/Net/"}]},{"title":"sql server connnect error: 233","slug":"sql-server-connnect-error-233","date":"2017-09-24T08:01:28.000Z","updated":"2018-01-25T12:31:26.767Z","comments":true,"path":"2017/09/24/sql-server-connnect-error-233/","link":"","permalink":"http://www.ariesjch.top/2017/09/24/sql-server-connnect-error-233/","excerpt":"Question:After openning sql server 2012, I click the connnecting buttion. However, sql server pop up the error message. 1error: 233 管道另一端无任何进程","text":"Question:After openning sql server 2012, I click the connnecting buttion. However, sql server pop up the error message. 1error: 233 管道另一端无任何进程 Solution: Open Microsoft SQL Server 2008–配置工具–SQL Server 配置管理器 “SQL Server 2008 网络配置”–”MSSQLSERVER的协议”–启用”TCP/IP”和”Named Pipes”.在启动TCP/IP协议后,还要把其属性中的TCP端口号改为1433(动态端口)或修改为自己想要的端口号. 重启”SQL Server”","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://www.ariesjch.top/tags/SQL/"}]},{"title":"Layout gets current user in the frontend","slug":"Layout-get-current-user-in-the-frontend","date":"2017-09-23T10:21:33.000Z","updated":"2018-01-25T12:31:25.963Z","comments":true,"path":"2017/09/23/Layout-get-current-user-in-the-frontend/","link":"","permalink":"http://www.ariesjch.top/2017/09/23/Layout-get-current-user-in-the-frontend/","excerpt":"Question:I need to change displayName according to current Account. Firstly, I try to create partial view. Partial view can get data individually but _layout can’t get data.Find solution in stackflow: Partial View shares data with _layout. In other words, Model is same in Partial View and _layout.","text":"Question:I need to change displayName according to current Account. Firstly, I try to create partial view. Partial view can get data individually but _layout can’t get data.Find solution in stackflow: Partial View shares data with _layout. In other words, Model is same in Partial View and _layout. Solution:We can get model in _layout directly in this method.12345678910111213@using LibraryProject.Models&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link href=\"~/favicon.ico?v=2\" rel=\"shortcut icon\" type=\"image/x-icon\" /&gt; &lt;title&gt;NWPU Library System&lt;/title&gt; &lt;meta content='width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no' name='viewport'&gt; &lt;!-- bootstrap 3.0.2 --&gt; &lt;link href=\"~/Content/css/bootstrap.min.css\" rel=\"stylesheet\" type=\"text/css\" /&gt; &lt;!-- font Awesome --&gt; &lt;link href=\"~/Content/css/font-awesome.min.css\" rel=\"stylesheet\" type=\"text/css\" /&gt; At the beginning, you should add @using LibraryProject.Models. And you can get context after that. 1234567891011121314 &lt;!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries --&gt; &lt;!-- WARNING: Respond.js doesn't work if you view the page via file:// --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=\"https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js\"&gt;&lt;/script&gt; &lt;script src=\"https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js\"&gt;&lt;/script&gt; &lt;![endif]--&gt; @Scripts.Render(\"http://cdn.datatables.net/1.10.15/js/jquery.dataTables.js\") @Styles.Render(\"http://cdn.datatables.net/1.10.15/css/jquery.dataTables.css\") @&#123; User user = (User)CheckLogin.Instance.GetUser(); &#125;&lt;/head&gt; Method:123@&#123; User user = (User)CheckLogin.Instance.GetUser();&#125; can get user Entity. And you can judge Authority and Role, etc… It’s excellent!!","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"asp.net mvc","slug":"asp-net-mvc","permalink":"http://www.ariesjch.top/tags/asp-net-mvc/"}]},{"title":"asp.net mvc Seed init","slug":"asp-net-mvc-Seed-init","date":"2017-09-21T04:34:40.000Z","updated":"2018-01-25T12:31:24.464Z","comments":true,"path":"2017/09/21/asp-net-mvc-Seed-init/","link":"","permalink":"http://www.ariesjch.top/2017/09/21/asp-net-mvc-Seed-init/","excerpt":"When I create Role for Library System project, I need to init seed for User Table. After Enable-migrations, you will find configuration.cs in the folder named Migrations. You should init data in this file.","text":"When I create Role for Library System project, I need to init seed for User Table. After Enable-migrations, you will find configuration.cs in the folder named Migrations. You should init data in this file. Code like this: 123456789101112131415161718192021222324252627282930313233343536373839404142434445protected override void Seed(LibraryProject.DAL.LibraryContext context) &#123; // This method will be called after migrating to the latest version. // You can use the DbSet&lt;T&gt;.AddOrUpdate() helper extension method // to avoid creating duplicate seed data. E.g. // // context.People.AddOrUpdate( // p =&gt; p.FullName, // new Person &#123; FullName = \"Andrew Peters\" &#125;, // new Person &#123; FullName = \"Brice Lambson\" &#125;, // new Person &#123; FullName = \"Rowan Miller\" &#125; // ); // context.Users.AddOrUpdate(ctx =&gt; ctx.UserName, new User &#123; UserName = \"admin\", Password = \"12345678\", PasswordComfirm = \"12345678\", Email = \"0000@qq.com\", PhoneNum = \"1212123123\", Role = \"admin\" &#125;, new User &#123; UserName = \"libraryadmin\", Password = \"87654321\", PasswordComfirm = \"87654321\", Email = \"1111@qq.com\", PhoneNum = \"1231231\", Role = \"libraryadmin\" &#125;, new User &#123; UserName = \"student\", Password = \"88888888\", PasswordComfirm = \"88888888\", Email = \"888@qq.com\", PhoneNum = \"123123\", Role = \"user\" &#125; ); &#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"asp.net mvc","slug":"asp-net-mvc","permalink":"http://www.ariesjch.top/tags/asp-net-mvc/"}]},{"title":"Newton.Json Serialize and Deserialize","slug":"Newton-Json-Serialize-and-Deserialize","date":"2017-09-20T15:26:23.000Z","updated":"2018-01-25T12:31:25.979Z","comments":true,"path":"2017/09/20/Newton-Json-Serialize-and-Deserialize/","link":"","permalink":"http://www.ariesjch.top/2017/09/20/Newton-Json-Serialize-and-Deserialize/","excerpt":"Json and Entity can convert each other by Newton.Json package. Entity to Json(string)JsonConvert.SerializeObject(user); Json(string) to EntityJsonConvert.DeserializeObject(string);","text":"Json and Entity can convert each other by Newton.Json package. Entity to Json(string)JsonConvert.SerializeObject(user); Json(string) to EntityJsonConvert.DeserializeObject(string);","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://www.ariesjch.top/tags/C/"}]},{"title":"asp.net mvc authority","slug":"asp-net-mvc-authority","date":"2017-09-20T15:08:17.000Z","updated":"2018-01-25T12:31:24.184Z","comments":true,"path":"2017/09/20/asp-net-mvc-authority/","link":"","permalink":"http://www.ariesjch.top/2017/09/20/asp-net-mvc-authority/","excerpt":"asp.net mvc Library project needs authority————————— 1.Create folder named Authority. 2.Create class named CheckLogin.cs","text":"asp.net mvc Library project needs authority————————— 1.Create folder named Authority. 2.Create class named CheckLogin.cs 1234567891011121314151617181920public class CheckLogin&#123; public readonly static CheckLogin Instance = new CheckLogin(); public bool IsLogin; public User GetUser() &#123; HttpCookie authCookie = HttpContext.Current.Request.Cookies[FormsAuthentication.FormsCookieName]; if(authCookie == null) &#123; return null; &#125; else &#123; FormsAuthenticationTicket Ticket = FormsAuthentication.Decrypt(authCookie.Value); return JsonConvert.DeserializeObject&lt;User&gt;(Ticket.UserData); &#125; &#125;&#125; 3.Create class named AuthAttribute.cs. In this class, we will override the method named OnActionExecuting(). 12345678910111213141516171819202122232425262728293031public class AuthAttribute : ActionFilterAttribute&#123; public string Code &#123; get; set; &#125; public override void OnActionExecuting(ActionExecutingContext filterContext) &#123; //如果不存在身份信息 HttpCookie authCookie = HttpContext.Current.Request.Cookies[FormsAuthentication.FormsCookieName]; if(authCookie == null) &#123; ContentResult Content = new ContentResult(); Content.Content = string.Format(\"&lt;script type='text/javascript'&gt;alert('请先登录！');window.location.href='&#123;0&#125;';&lt;/script&gt;\", FormsAuthentication.LoginUrl); filterContext.Result = Content; &#125; else &#123; /* var Instance = CheckLogin.Instance; var user = Instance.GetUser(); var Roles = user.Role; string[] Role = Roles.Split(','); */ string[] Role = CheckLogin.Instance.GetUser().Role.Split(',');//获取所有角色 if (!Role.Contains(Code))//验证权限 &#123; //验证不通过 ContentResult Content = new ContentResult(); Content.Content = \"&lt;script type='text/javascript'&gt;alert('权限验证不通过！');history.go(-1);&lt;/script&gt;\"; filterContext.Result = Content; &#125; &#125; &#125;&#125; 4.In the UsersController.cs, we should create cookie for current user after confirming that whether UserName and Password are valid. 1234567891011121314151617181920212223242526272829303132333435[HttpPost] public ActionResult Login([Bind(Include =\"UserName,Password\")] User user) &#123; var userObj = unitOfWork.UserRepository.Get() .Where(item =&gt; item.UserName.Equals(user.UserName) == true) .ToList(); if(userObj[0] != null) &#123; if (userObj[0].Password.Equals(user.Password) == true) &#123; CheckLogin.Instance.IsLogin = true; // Session 实现 // 序列化用户实体 string UserData = JsonConvert.SerializeObject(userObj[0]); // 保存身份信息 FormsAuthenticationTicket Ticket = new FormsAuthenticationTicket(1, user.UserName, DateTime.Now, DateTime.Now.AddHours(12), false, UserData); HttpCookie Cookie = new HttpCookie(FormsAuthentication.FormsCookieName, FormsAuthentication.Encrypt(Ticket)); Response.Cookies.Add(Cookie); //return RedirectToAction(\"Index\",\"Books\",\"Index\"); return Redirect(\"/Home/Index/\"); &#125; &#125; else &#123; ModelState.AddModelError(\"UserName\", \"No User\"); &#125; return View(user); &#125; 5.Logout Method 123456// 注销登录 public ActionResult Logout() &#123; FormsAuthentication.SignOut(); return Redirect(\"/Home/Index/\"); &#125; 6.Before the method that we want to add authority, we should add [Auth(Code =”libraryadmin,admin”)].","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"asp.net mvc","slug":"asp-net-mvc","permalink":"http://www.ariesjch.top/tags/asp-net-mvc/"}]},{"title":"asp.net mvc favicon change","slug":"asp-net-mvc-favicon-change","date":"2017-09-19T06:38:04.000Z","updated":"2018-01-25T12:31:24.289Z","comments":true,"path":"2017/09/19/asp-net-mvc-favicon-change/","link":"","permalink":"http://www.ariesjch.top/2017/09/19/asp-net-mvc-favicon-change/","excerpt":"When I change website’s favicon, I find that it doesn’t work. After cleaning the browser’s cache, it also doesn’t work.Because browser doesn’t cache favicon.","text":"When I change website’s favicon, I find that it doesn’t work. After cleaning the browser’s cache, it also doesn’t work.Because browser doesn’t cache favicon. Solution: In _layout.cshtml, you can change the url of favicon. Like this: &lt;link href=&quot;~/favicon.ico?v=2&quot; rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; /&gt; Reference Link:http://findnerd.com/list/view/How-to-set-favicon-in-Asp-net-mvc/21886/","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"asp.net mvc","slug":"asp-net-mvc","permalink":"http://www.ariesjch.top/tags/asp-net-mvc/"}]},{"title":"asp.net mvc connect to sql server 2012","slug":"asp-net-mvc-connect-sql-server-2012","date":"2017-09-18T11:11:26.000Z","updated":"2018-01-25T12:31:24.201Z","comments":true,"path":"2017/09/18/asp-net-mvc-connect-sql-server-2012/","link":"","permalink":"http://www.ariesjch.top/2017/09/18/asp-net-mvc-connect-sql-server-2012/","excerpt":"During developing the Library System, I need to connect to sql server. It needs to use , like this:","text":"During developing the Library System, I need to connect to sql server. It needs to use , like this: 123&lt;connectionStrings&gt; &lt;add name=\"LibraryContext\" connectionString=\"Data Source=.;database=MvcDemo;uid=sa;pwd=123456;AttachDBFilename=|DataDirectory|\\Library.mdf;\" providerName=\"System.Data.SqlClient\" /&gt; &lt;/connectionStrings&gt;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"asp.net mvc","slug":"asp-net-mvc","permalink":"http://www.ariesjch.top/tags/asp-net-mvc/"}]},{"title":"asp.net mvc Datatable","slug":"asp-net-mvc-Datatable","date":"2017-09-17T15:58:24.000Z","updated":"2018-01-25T12:31:24.228Z","comments":true,"path":"2017/09/17/asp-net-mvc-Datatable/","link":"","permalink":"http://www.ariesjch.top/2017/09/17/asp-net-mvc-Datatable/","excerpt":"Bug Information: When I develop asp.net mvc project, I want to use Datatable to achieve the sort of data and search specific data in the table. I introduced the script and css, but it didn’t work.","text":"Bug Information: When I develop asp.net mvc project, I want to use Datatable to achieve the sort of data and search specific data in the table. I introduced the script and css, but it didn’t work. Finally, I found the solutions: Jquery.js must be introduced before datatable.js, and you should look that whether jquery was introduced twice in _layout.cshtml and “view”.cshtml.","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"asp.net mvc","slug":"asp-net-mvc","permalink":"http://www.ariesjch.top/tags/asp-net-mvc/"}]},{"title":"字符串正则表达式 C#工程使用","slug":"C-string-validate","date":"2017-08-24T11:29:23.000Z","updated":"2018-01-25T12:31:24.863Z","comments":true,"path":"2017/08/24/C-string-validate/","link":"","permalink":"http://www.ariesjch.top/2017/08/24/C-string-validate/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280using System;using System.Text.RegularExpressions;namespace MetarCommonSupport&#123; /// &lt;summary&gt; /// 通过Framwork类库中的Regex类实现了一些特殊功能数据检查 /// &lt;/summary&gt; public class MetarnetRegex &#123; private static MetarnetRegex instance = null; public static MetarnetRegex GetInstance() &#123; if (MetarnetRegex.instance == null) &#123; MetarnetRegex.instance = new MetarnetRegex(); &#125; return MetarnetRegex.instance; &#125; private MetarnetRegex() &#123; &#125; /// &lt;summary&gt; /// 判断输入的字符串只包含汉字 /// &lt;/summary&gt; /// &lt;param name=\"input\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsChineseCh(string input) &#123; Regex regex = new Regex(\"^[\\u4e00-\\u9fa5]+$\"); return regex.IsMatch(input); &#125; /// &lt;summary&gt; /// 匹配3位或4位区号的电话号码，其中区号可以用小括号括起来， /// 也可以不用，区号与本地号间可以用连字号或空格间隔， /// 也可以没有间隔 /// \\(0\\d&#123;2&#125;\\)[- ]?\\d&#123;8&#125;|0\\d&#123;2&#125;[- ]?\\d&#123;8&#125;|\\(0\\d&#123;3&#125;\\)[- ]?\\d&#123;7&#125;|0\\d&#123;3&#125;[- ]?\\d&#123;7&#125; /// &lt;/summary&gt; /// &lt;param name=\"input\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsPhone(string input) &#123; string pattern = \"^\\\\(0\\\\d&#123;2&#125;\\\\)[- ]?\\\\d&#123;8&#125;$|^0\\\\d&#123;2&#125;[- ]?\\\\d&#123;8&#125;$|^\\\\(0\\\\d&#123;3&#125;\\\\)[- ]?\\\\d&#123;7&#125;$|^0\\\\d&#123;3&#125;[- ]?\\\\d&#123;7&#125;$\"; Regex regex = new Regex(pattern); return regex.IsMatch(input); &#125; /// &lt;summary&gt; /// 判断输入的字符串是否是一个合法的手机号 /// &lt;/summary&gt; /// &lt;param name=\"input\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsMobilePhone(string input) &#123; Regex regex = new Regex(\"^13\\\\d&#123;9&#125;$\"); return regex.IsMatch(input); &#125; /// &lt;summary&gt; /// 判断输入的字符串只包含数字 /// 可以匹配整数和浮点数 /// ^-?\\d+$|^(-?\\d+)(\\.\\d+)?$ /// &lt;/summary&gt; /// &lt;param name=\"input\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsNumber(string input) &#123; string pattern = \"^-?\\\\d+$|^(-?\\\\d+)(\\\\.\\\\d+)?$\"; Regex regex = new Regex(pattern); return regex.IsMatch(input); &#125; /// &lt;summary&gt; /// 匹配非负整数 /// /// &lt;/summary&gt; /// &lt;param name=\"input\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsNotNagtive(string input) &#123; Regex regex = new Regex(@\"^\\d+$\"); return regex.IsMatch(input); &#125; /// &lt;summary&gt; /// 匹配正整数 /// &lt;/summary&gt; /// &lt;param name=\"input\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsUint(string input) &#123; Regex regex = new Regex(\"^[0-9]*[1-9][0-9]*$\"); return regex.IsMatch(input); &#125; /// &lt;summary&gt; /// 判断输入的字符串字包含英文字母 /// &lt;/summary&gt; /// &lt;param name=\"input\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsEnglisCh(string input) &#123; Regex regex = new Regex(\"^[A-Za-z]+$\"); return regex.IsMatch(input); &#125; /// &lt;summary&gt; /// 判断输入的字符串是否是一个合法的Email地址 /// &lt;/summary&gt; /// &lt;param name=\"input\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsEmail(string input) &#123; string pattern = @\"^([\\w-\\.]+)@((\\[[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.)|(([\\w-]+\\.)+))([a-zA-Z]&#123;2,4&#125;|[0-9]&#123;1,3&#125;)(\\]?)$\"; Regex regex = new Regex(pattern); return regex.IsMatch(input); &#125; /// &lt;summary&gt; /// 判断输入的字符串是否只包含数字和英文字母 /// &lt;/summary&gt; /// &lt;param name=\"input\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsNumAndEnCh(string input) &#123; string pattern = @\"^[A-Za-z0-9]+$\"; Regex regex = new Regex(pattern); return regex.IsMatch(input); &#125; /// &lt;summary&gt; /// 判断输入的字符串是否是一个超链接 /// &lt;/summary&gt; /// &lt;param name=\"input\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsURL(string input) &#123; //string pattern = @\"http://([\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&amp;=]*)?\"; string pattern = @\"^[a-zA-Z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$\"; Regex regex = new Regex(pattern); return regex.IsMatch(input); &#125; /// &lt;summary&gt; /// 判断输入的字符串是否是表示一个IP地址 /// &lt;/summary&gt; /// &lt;param name=\"input\"&gt;被比较的字符串&lt;/param&gt; /// &lt;returns&gt;是IP地址则为True&lt;/returns&gt; public static bool IsIPv4(string input) &#123; string[] IPs = input.Split('.'); Regex regex = new Regex(@\"^\\d+$\"); for (int i = 0; i &lt; IPs.Length; i++) &#123; if (!regex.IsMatch(IPs[i])) &#123; return false; &#125; if (Convert.ToUInt16(IPs[i]) &gt; 255) &#123; return false; &#125; &#125; return true; &#125; /// &lt;summary&gt; /// 计算字符串的字符长度，一个汉字字符将被计算为两个字符 /// &lt;/summary&gt; /// &lt;param name=\"input\"&gt;需要计算的字符串&lt;/param&gt; /// &lt;returns&gt;返回字符串的长度&lt;/returns&gt; public static int GetCount(string input) &#123; return Regex.Replace(input, @\"[\\u4e00-\\u9fa5/g]\", \"aa\").Length; &#125; /// &lt;summary&gt; /// 调用Regex中IsMatch函数实现一般的正则表达式匹配 /// &lt;/summary&gt; /// &lt;param name=\"pattern\"&gt;要匹配的正则表达式模式。&lt;/param&gt; /// &lt;param name=\"input\"&gt;要搜索匹配项的字符串&lt;/param&gt; /// &lt;returns&gt;如果正则表达式找到匹配项，则为 true；否则，为 false。&lt;/returns&gt; public static bool IsMatch(string pattern, string input) &#123; Regex regex = new Regex(pattern); return regex.IsMatch(input); &#125; /// &lt;summary&gt; /// 从输入字符串中的第一个字符开始，用替换字符串替换指定的正则表达式模式的所有匹配项。 /// &lt;/summary&gt; /// &lt;param name=\"pattern\"&gt;模式字符串&lt;/param&gt; /// &lt;param name=\"input\"&gt;输入字符串&lt;/param&gt; /// &lt;param name=\"replacement\"&gt;用于替换的字符串&lt;/param&gt; /// &lt;returns&gt;返回被替换后的结果&lt;/returns&gt; public static string Replace(string pattern, string input, string replacement) &#123; Regex regex = new Regex(pattern); return regex.Replace(input, replacement); &#125; /// &lt;summary&gt; /// 在由正则表达式模式定义的位置拆分输入字符串。 /// &lt;/summary&gt; /// &lt;param name=\"pattern\"&gt;模式字符串&lt;/param&gt; /// &lt;param name=\"input\"&gt;输入字符串&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string[] Split(string pattern, string input) &#123; Regex regex = new Regex(pattern); return regex.Split(input); &#125; /// &lt;summary&gt; /// 判断输入的字符串是否是合法的IPV6 地址 /// &lt;/summary&gt; /// &lt;param name=\"input\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsIPV6(string input) &#123; string pattern = \"\"; string temp = input; string[] strs = temp.Split(':'); if (strs.Length &gt; 8) &#123; return false; &#125; int count = MetarnetRegex.GetStringCount(input, \"::\"); if (count &gt; 1) &#123; return false; &#125; else if (count == 0) &#123; pattern = @\"^([\\da-f]&#123;1,4&#125;:)&#123;7&#125;[\\da-f]&#123;1,4&#125;$\"; Regex regex = new Regex(pattern); return regex.IsMatch(input); &#125; else &#123; pattern = @\"^([\\da-f]&#123;1,4&#125;:)&#123;0,5&#125;::([\\da-f]&#123;1,4&#125;:)&#123;0,5&#125;[\\da-f]&#123;1,4&#125;$\"; Regex regex1 = new Regex(pattern); return regex1.IsMatch(input); &#125; &#125; /* ******************************************************************* * 1、通过“:”来分割字符串看得到的字符串数组长度是否小于等于8 * 2、判断输入的IPV6字符串中是否有“::”。 * 3、如果没有“::”采用 ^([\\da-f]&#123;1,4&#125;:)&#123;7&#125;[\\da-f]&#123;1,4&#125;$ 来判断 * 4、如果有“::” ，判断\"::\"是否止出现一次 * 5、如果出现一次以上 返回false * 6、^([\\da-f]&#123;1,4&#125;:)&#123;0,5&#125;::([\\da-f]&#123;1,4&#125;:)&#123;0,5&#125;[\\da-f]&#123;1,4&#125;$ * ******************************************************************/ /// &lt;summary&gt; /// 判断字符串compare 在 input字符串中出现的次数 /// &lt;/summary&gt; /// &lt;param name=\"input\"&gt;源字符串&lt;/param&gt; /// &lt;param name=\"compare\"&gt;用于比较的字符串&lt;/param&gt; /// &lt;returns&gt;字符串compare 在 input字符串中出现的次数&lt;/returns&gt; private static int GetStringCount(string input, string compare) &#123; int index = input.IndexOf(compare); if (index != -1) &#123; return 1 + GetStringCount(input.Substring(index + compare.Length), compare); &#125; else &#123; return 0; &#125; &#125; &#125;&#125;","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://www.ariesjch.top/tags/C/"}]},{"title":" hexo YAMLException: cannot read a block mapping entry; a multi line key may not be an implicit key a","slug":"hexo-YAMLException-cannot-read-a-block-mapping-entry-a-multi-line-key-may-not-be-an-implicit-key-a","date":"2017-08-14T02:35:06.000Z","updated":"2018-01-25T12:31:25.272Z","comments":true,"path":"2017/08/14/hexo-YAMLException-cannot-read-a-block-mapping-entry-a-multi-line-key-may-not-be-an-implicit-key-a/","link":"","permalink":"http://www.ariesjch.top/2017/08/14/hexo-YAMLException-cannot-read-a-block-mapping-entry-a-multi-line-key-may-not-be-an-implicit-key-a/","excerpt":"Solution：When you edit _config.yml, you should add a space before editing the contents of each attribute.","text":"Solution：When you edit _config.yml, you should add a space before editing the contents of each attribute.","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"github","slug":"github","permalink":"http://www.ariesjch.top/tags/github/"}]},{"title":"GIT Commands --- pull new changes","slug":"git-pull new changes","date":"2017-08-11T14:50:48.000Z","updated":"2018-01-25T12:31:25.220Z","comments":true,"path":"2017/08/11/git-pull new changes/","link":"","permalink":"http://www.ariesjch.top/2017/08/11/git-pull new changes/","excerpt":"12345678910git remote add liuw https://github.com/liuw/xxx.git git branch --list --all git fetch liuw git stash git rebase liuw/master Open VS CODE, and solve the conflicts. git add . git rebase --continue git stash pop","text":"12345678910git remote add liuw https://github.com/liuw/xxx.git git branch --list --all git fetch liuw git stash git rebase liuw/master Open VS CODE, and solve the conflicts. git add . git rebase --continue git stash pop When you want to get the new changes, you can use this command. 1git reset liuw/master --hard","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"github","slug":"github","permalink":"http://www.ariesjch.top/tags/github/"}]},{"title":"Common commands of Hexo","slug":"hexo commands","date":"2017-08-11T13:20:05.000Z","updated":"2018-01-25T12:31:25.244Z","comments":true,"path":"2017/08/11/hexo commands/","link":"","permalink":"http://www.ariesjch.top/2017/08/11/hexo commands/","excerpt":"hexo commands：hexo new &quot;postName&quot; # Create a new article hexo new page &quot;pageName&quot; # Create a new page hexo generate # Generate static pages in &quot;public&quot; hexo server # Open the Preview and access the port of 4000 hexo deploy # Deploy to github hexo help # View help hexo version # View the version of Hexo","text":"hexo commands：hexo new &quot;postName&quot; # Create a new article hexo new page &quot;pageName&quot; # Create a new page hexo generate # Generate static pages in &quot;public&quot; hexo server # Open the Preview and access the port of 4000 hexo deploy # Deploy to github hexo help # View help hexo version # View the version of Hexo","categories":[{"name":"技术篇","slug":"技术篇","permalink":"http://www.ariesjch.top/categories/技术篇/"}],"tags":[{"name":"github","slug":"github","permalink":"http://www.ariesjch.top/tags/github/"}]}]}